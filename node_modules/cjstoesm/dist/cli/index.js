import {
  Logger,
  createTransformTaskOptions,
  transformTask
} from "../chunk-NOCWFHS7.js";

// src/cli/configure-commands.ts
import { Command } from "commander";

// src/cli/command/create-command/create-command.ts
function coerceOptionValue(type, value) {
  switch (type) {
    case "string":
      if (value === null) return "null";
      else if (value === void 0) return "undefined";
      return String(value);
    case "number":
      if (typeof value === "number") return value;
      else if (value === true) return 1;
      else if (value === false) return 0;
      return parseFloat(value);
    case "boolean":
      if (value === "true" || value === "" || value === "1" || value === 1) return true;
      else if (value === "false" || value === "0" || value === 0) return false;
      return Boolean(value);
  }
}
function formatOptionFlags(shortHand, longHand) {
  const formattedLongHand = `${longHand} [arg]`;
  return shortHand != null ? `-${shortHand}, --${formattedLongHand}` : `--${formattedLongHand}`;
}
function formatCommandNameWithArgs(options) {
  const formattedArgs = Object.entries(options.args).map(([argName, { type, required }]) => {
    const left = required ? `<` : `[`;
    const right = required ? ">" : `]`;
    if (type === "string[]") {
      return `${left}${argName}...${right}`;
    } else {
      return `${left}${argName}${right}`;
    }
  }).join(" ");
  return `${options.name} ${formattedArgs}`;
}
function createCommand(program, options, action) {
  const result = program.command(formatCommandNameWithArgs(options), {
    isDefault: options.isDefault
  }).description(options.description);
  Object.entries(options.options).forEach(([longhand, { shortHand, description, type, defaultValue }]) => {
    result.option(formatOptionFlags(shortHand, longhand), description, coerceOptionValue.bind(null, type), defaultValue);
  });
  result.action((...args) => {
    const actionOptions = {};
    let offset = 0;
    for (const key of Object.keys(options.args)) {
      actionOptions[key] = args[offset++];
    }
    Object.assign(actionOptions, args[offset]);
    action(actionOptions);
  });
}

// src/cli/command/transform/inject-transform-command.ts
function injectTransformCommand(options) {
  createCommand(
    options.program,
    {
      name: "transform",
      description: `Transforms CJS to ESM modules based on the input glob`,
      isDefault: true,
      args: {
        input: {
          type: "string",
          required: true,
          description: "A glob for all the files that should be transformed"
        },
        outDir: {
          type: "string",
          required: false,
          description: `Optionally, the directory to write the transformed files to. Defaults to overwriting the matched input files`
        }
      },
      options: {
        debug: {
          shortHand: "d",
          type: "boolean",
          description: "Whether to print debug information"
        },
        verbose: {
          shortHand: "v",
          type: "boolean",
          description: "Whether to print verbose information"
        },
        silent: {
          shortHand: "s",
          type: "boolean",
          description: "Whether to not print anything"
        },
        cwd: {
          shortHand: "c",
          type: "string",
          description: `Optionally which directory to use as the current working directory`
        },
        "preserve-module-specifiers": {
          shortHand: "p",
          type: "string",
          defaultValue: "external",
          description: `Determines whether or not module specifiers are preserved. Possible values are: "external", "internal", "always", and "never"`
        },
        "import-attributes": {
          shortHand: "a",
          type: "boolean",
          defaultValue: true,
          description: `Determines whether or not Import Attributes are included where they are relevant. Possible values are: true and false`
        },
        dry: {
          shortHand: "m",
          type: "boolean",
          description: "If true, no files will be written to disk"
        }
      }
    },
    async (args) => {
      const logger = new Logger(args.debug ? 3 /* DEBUG */ : args.verbose ? 2 /* VERBOSE */ : args.silent ? 0 /* NONE */ : 1 /* INFO */);
      if (logger.logLevel === 2 /* VERBOSE */) {
        logger.verbose(`Logging mode: VERBOSE`);
      } else if (logger.logLevel === 3 /* DEBUG */) {
        logger.debug(`Logging mode: DEBUG`);
      }
      const taskOptions = createTransformTaskOptions({
        ...options,
        ...args,
        logger,
        write: !args.dry
      });
      await transformTask(taskOptions);
    }
  );
}

// src/cli/configure-commands.ts
function configureCommands({
  keepAliveOnError = false,
  commandLoaders = [injectTransformCommand],
  args = [...process.argv],
  ...injectCommandOptions
} = {}) {
  const program = new Command();
  if (keepAliveOnError) {
    program.exitOverride();
  }
  for (const commandLoader of commandLoaders) {
    commandLoader({ ...injectCommandOptions, program });
  }
  if (args[2] !== "transform") {
    args.splice(2, 0, "transform");
  }
  program.parse(args);
}

// src/cli/auto-configure-commands.ts
configureCommands();
//# sourceMappingURL=index.js.map