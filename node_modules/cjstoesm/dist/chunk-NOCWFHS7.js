// src/transformer/util/resolve-path.ts
import resolve from "resolve";
import path2 from "crosspath";

// src/transformer/util/path-util.ts
import { normalize } from "crosspath";
var KNOWN_EXTENSIONS = [
  ".d.ts",
  ".d.dts.map",
  ".js.map",
  ".ts",
  ".tsx",
  ".js",
  ".jsx",
  ".mjs",
  ".mjs.map",
  ".mjsx",
  ".cjs",
  ".cjs.map",
  ".csjx",
  ".d.cts",
  ".d.cts.map",
  ".d.mts",
  ".d.mts.map",
  ".json",
  ".tsbuildinfo"
];
function ensureHasLeadingDotAndPosix(p) {
  const posixPath = normalize(p);
  if (posixPath.startsWith(".")) return posixPath;
  if (posixPath.startsWith("/")) return `.${posixPath}`;
  return `./${posixPath}`;
}
function stripKnownExtension(file) {
  let currentExtname;
  for (const extName of KNOWN_EXTENSIONS) {
    if (file.endsWith(extName)) {
      currentExtname = extName;
      break;
    }
  }
  if (currentExtname == null) return file;
  return file.slice(0, file.lastIndexOf(currentExtname));
}
function setExtension(file, extension) {
  return normalize(`${stripKnownExtension(file)}${extension}`);
}
function isExternalLibrary(p) {
  return !p.startsWith(".") && !p.startsWith("/");
}
function isJsonModule(p) {
  return p.endsWith(`.json`);
}

// src/shared/util/util.ts
import path from "crosspath";
function isArray(value) {
  return Array.isArray(value);
}
function ensureArray(item) {
  return Array.isArray(item) ? item : [item];
}
function getFolderClosestToRoot(root, files) {
  const [head] = files;
  if (head == null) {
    throw new ReferenceError(`At least 1 file must be provided`);
  }
  let candidate = head;
  for (const file of files) {
    const relativeToRoot = path.relative(root, file);
    if (relativeToRoot.split("/").length < candidate.split("/").length) {
      candidate = relativeToRoot;
    }
  }
  return path.join(root, path.dirname(candidate));
}
function normalizeGlob(glob) {
  return path.extname(glob) === "" && !glob.endsWith("*") ? `${glob}/*` : glob;
}
function isRecord(value) {
  return !Array.isArray(value) && typeof value === "object" && value != null && !(value instanceof Date) && !(value instanceof Set) && !(value instanceof WeakSet) && !(value instanceof Map) && !(value instanceof WeakMap);
}
function canHaveModifiers(node, typescript) {
  if ("canHaveModifiers" in typescript) {
    return typescript.canHaveModifiers(node);
  } else {
    return true;
  }
}
function getModifiers(node, typescript) {
  if ("getModifiers" in typescript) {
    return typescript.getModifiers(node);
  } else {
    return node.modifiers?.filter((modifier) => !("expression" in modifier));
  }
}
function canHaveDecorators(node, typescript) {
  if ("canHaveDecorators" in typescript) {
    return typescript.canHaveDecorators(node);
  } else {
    return true;
  }
}
function getDecorators(node, typescript) {
  if ("getDecorators" in typescript) {
    return typescript.getDecorators(node);
  } else {
    const legacyDecorators = "decorators" in node && isArray(node.decorators) ? node.decorators : void 0;
    const decoratorModifierLikes = node.modifiers?.filter((modifier) => "expression" in modifier);
    return [...legacyDecorators ?? [], ...decoratorModifierLikes ?? []];
  }
}
function addExportModifier(node, typescript, factory) {
  return addModifier(node, typescript, factory, typescript.SyntaxKind.ExportKeyword);
}
function hasExportModifier(node, typescript) {
  return hasModifier(node, typescript, typescript.SyntaxKind.ExportKeyword);
}
function hasDefaultExportModifier(node, typescript) {
  return hasExportModifier(node, typescript) && hasModifier(node, typescript, typescript.SyntaxKind.DefaultKeyword);
}
function hasModifier(node, typescript, modifier) {
  return canHaveModifiers(node, typescript) ? Boolean(node.modifiers?.some((m) => m.kind === modifier)) : false;
}
function addModifier(node, typescript, factory, modifier) {
  const modifiers = getModifiers(node, typescript) ?? [];
  if (modifiers.some((m) => m.kind === modifier)) return modifiers;
  if (!canHaveDecorators(node, typescript)) {
    return [factory.createModifier(modifier), ...modifiers.map((m) => factory.createModifier(m.kind))];
  } else {
    const decorators = getDecorators(node, typescript) ?? [];
    return [factory.createModifier(modifier), ...modifiers.map((m) => factory.createModifier(m.kind)), ...decorators.map((decorator) => factory.createDecorator(decorator.expression))];
  }
}
function isTypeAssertionExpression(node, typescript) {
  if ("isTypeAssertionExpression" in typescript) {
    return typescript.isTypeAssertionExpression(node);
  } else {
    return Boolean(typescript.isTypeAssertion?.(node));
  }
}

// src/transformer/util/resolve-path.ts
function computeCacheKey(id, parent) {
  return isExternalLibrary(id) ? id : `${parent == null ? "" : `${parent}->`}${id}`;
}
function resolvePath({
  id,
  parent,
  cwd,
  prioritizedPackageKeys = ["exports", "es2015", "esm2015", "module", "jsnext:main", "main", "browser"],
  prioritizedExtensions = ["", ".js", ".mjs", ".cjs", ".jsx", ".ts", ".mts", ".cts", ".tsx", ".json"],
  moduleDirectory = "node_modules",
  fileSystem,
  resolveCache
}) {
  id = path2.normalize(id);
  if (parent != null) {
    parent = path2.normalize(parent);
  }
  const cacheKey = computeCacheKey(id, parent);
  const cacheResult = resolveCache.get(cacheKey);
  if (cacheResult != null) return cacheResult;
  if (cacheResult === null) return;
  if (!isExternalLibrary(id)) {
    const absolute = path2.isAbsolute(id) ? path2.normalize(id) : path2.join(parent == null ? "" : path2.dirname(parent), id);
    const variants = [absolute, path2.join(absolute, "index")];
    for (const variant of variants) {
      for (const ext of prioritizedExtensions) {
        const withExtension = `${variant}${ext}`;
        if (fileSystem.safeStatSync(withExtension)?.isFile() ?? false) {
          resolveCache.set(cacheKey, withExtension);
          return withExtension;
        }
      }
    }
    resolveCache.set(cacheKey, null);
    return void 0;
  }
  try {
    const resolveResult = path2.normalize(
      resolve.sync(id, {
        basedir: path2.normalize(cwd),
        extensions: prioritizedExtensions,
        moduleDirectory,
        readFileSync: (p) => fileSystem.readFileSync(p).toString(),
        isFile: (p) => fileSystem.safeStatSync(p)?.isFile() ?? false,
        isDirectory: (p) => fileSystem.safeStatSync(p)?.isDirectory() ?? false,
        packageFilter(pkg) {
          let property;
          if (property == null) {
            const packageKeys = Object.keys(pkg);
            property = prioritizedPackageKeys.find((key) => packageKeys.includes(key));
          }
          if (property != null) {
            let pickedProperty = pkg[property];
            while (isRecord(pickedProperty)) {
              if ("import" in pickedProperty) {
                pickedProperty = pickedProperty.import;
              } else if ("." in pickedProperty) {
                pickedProperty = pickedProperty["."];
              } else if ("default" in pickedProperty) {
                pickedProperty = pickedProperty.default;
              } else if ("require" in pickedProperty) {
                pickedProperty = pickedProperty.require;
              } else {
                pickedProperty = pickedProperty[Object.keys(pickedProperty)[0]];
              }
            }
            pkg.main = pickedProperty;
          }
          return pkg;
        }
      })
    );
    resolveCache.set(cacheKey, resolveResult);
    return resolveResult;
  } catch {
    resolveCache.set(cacheKey, null);
    return void 0;
  }
}

// src/transformer/util/walk-through-filler-nodes.ts
function walkThroughFillerNodes(expression, typescript) {
  if (typescript.isParenthesizedExpression(expression) || typescript.isAsExpression(expression) || isTypeAssertionExpression(expression, typescript) || typescript.isNonNullExpression(expression) || typescript.isExpressionWithTypeArguments(expression)) {
    return expression.expression;
  }
  return expression;
}

// src/transformer/built-in/built-in-module-map.ts
var BUILT_IN_MODULE = /* @__PURE__ */ new Set([
  "assert",
  "assert/strict",
  "async_hooks",
  "buffer",
  "child_process",
  "cluster",
  "console",
  "constants",
  "crypto",
  "dgram",
  "diagnostics_channel",
  "dns",
  "dns/promises",
  "domain",
  "events",
  "fs",
  "fs/promises",
  "http",
  "http2",
  "https",
  "inspector",
  "inspector/promises",
  "module",
  "net",
  "os",
  "path",
  "path/posix",
  "path/win32",
  "perf_hooks",
  "process",
  "punycode",
  "querystring",
  "readline",
  "readline/promises",
  "repl",
  "stream",
  "stream/consumers",
  "stream/promises",
  "stream/web",
  "string_decoder",
  "timers",
  "timers/promises",
  "tls",
  "trace_events",
  "tty",
  "url",
  "util",
  "util/types",
  "v8",
  "vm",
  "wasi",
  "worker_threads",
  "zlib"
]);
function isBuiltInModule(moduleName) {
  return BUILT_IN_MODULE.has(moduleName);
}
var BUILT_IN_MODULE_MAP = {
  assert: {
    namedExports: /* @__PURE__ */ new Set([]),
    hasDefaultExport: true
  },
  "assert/strict": {
    namedExports: /* @__PURE__ */ new Set([]),
    hasDefaultExport: true
  },
  async_hooks: {
    namedExports: /* @__PURE__ */ new Set(["AsyncLocalStorage", "createHook", "executionAsyncId", "triggerAsyncId", "executionAsyncResource", "asyncWrapProviders", "AsyncResource"]),
    hasDefaultExport: true
  },
  buffer: {
    namedExports: /* @__PURE__ */ new Set([
      "Buffer",
      "SlowBuffer",
      "transcode",
      "isUtf8",
      "isAscii",
      "kMaxLength",
      "kStringMaxLength",
      "btoa",
      "atob",
      "constants",
      "INSPECT_MAX_BYTES",
      "Blob",
      "resolveObjectURL",
      "File"
    ]),
    hasDefaultExport: true
  },
  child_process: {
    namedExports: /* @__PURE__ */ new Set(["ChildProcess", "exec", "execFile", "execFileSync", "execSync", "fork", "spawn", "spawnSync"]),
    hasDefaultExport: true
  },
  cluster: {
    namedExports: /* @__PURE__ */ new Set([
      "isWorker",
      "isMaster",
      "isPrimary",
      "Worker",
      "workers",
      "settings",
      "SCHED_NONE",
      "SCHED_RR",
      "schedulingPolicy",
      "setupPrimary",
      "setupMaster",
      "fork",
      "disconnect"
    ]),
    hasDefaultExport: true
  },
  console: {
    namedExports: /* @__PURE__ */ new Set([
      "log",
      "warn",
      "error",
      "dir",
      "time",
      "timeEnd",
      "timeLog",
      "trace",
      "assert",
      "clear",
      "count",
      "countReset",
      "group",
      "groupEnd",
      "table",
      "debug",
      "info",
      "dirxml",
      "groupCollapsed",
      "Console",
      "profile",
      "profileEnd",
      "timeStamp",
      "context",
      "createTask"
    ]),
    hasDefaultExport: true
  },
  constants: {
    namedExports: /* @__PURE__ */ new Set([
      "RTLD_LAZY",
      "RTLD_NOW",
      "RTLD_GLOBAL",
      "RTLD_LOCAL",
      "E2BIG",
      "EACCES",
      "EADDRINUSE",
      "EADDRNOTAVAIL",
      "EAFNOSUPPORT",
      "EAGAIN",
      "EALREADY",
      "EBADF",
      "EBADMSG",
      "EBUSY",
      "ECANCELED",
      "ECHILD",
      "ECONNABORTED",
      "ECONNREFUSED",
      "ECONNRESET",
      "EDEADLK",
      "EDESTADDRREQ",
      "EDOM",
      "EDQUOT",
      "EEXIST",
      "EFAULT",
      "EFBIG",
      "EHOSTUNREACH",
      "EIDRM",
      "EILSEQ",
      "EINPROGRESS",
      "EINTR",
      "EINVAL",
      "EIO",
      "EISCONN",
      "EISDIR",
      "ELOOP",
      "EMFILE",
      "EMLINK",
      "EMSGSIZE",
      "EMULTIHOP",
      "ENAMETOOLONG",
      "ENETDOWN",
      "ENETRESET",
      "ENETUNREACH",
      "ENFILE",
      "ENOBUFS",
      "ENODATA",
      "ENODEV",
      "ENOENT",
      "ENOEXEC",
      "ENOLCK",
      "ENOLINK",
      "ENOMEM",
      "ENOMSG",
      "ENOPROTOOPT",
      "ENOSPC",
      "ENOSR",
      "ENOSTR",
      "ENOSYS",
      "ENOTCONN",
      "ENOTDIR",
      "ENOTEMPTY",
      "ENOTSOCK",
      "ENOTSUP",
      "ENOTTY",
      "ENXIO",
      "EOPNOTSUPP",
      "EOVERFLOW",
      "EPERM",
      "EPIPE",
      "EPROTO",
      "EPROTONOSUPPORT",
      "EPROTOTYPE",
      "ERANGE",
      "EROFS",
      "ESPIPE",
      "ESRCH",
      "ESTALE",
      "ETIME",
      "ETIMEDOUT",
      "ETXTBSY",
      "EWOULDBLOCK",
      "EXDEV",
      "PRIORITY_LOW",
      "PRIORITY_BELOW_NORMAL",
      "PRIORITY_NORMAL",
      "PRIORITY_ABOVE_NORMAL",
      "PRIORITY_HIGH",
      "PRIORITY_HIGHEST",
      "SIGHUP",
      "SIGINT",
      "SIGQUIT",
      "SIGILL",
      "SIGTRAP",
      "SIGABRT",
      "SIGIOT",
      "SIGBUS",
      "SIGFPE",
      "SIGKILL",
      "SIGUSR1",
      "SIGSEGV",
      "SIGUSR2",
      "SIGPIPE",
      "SIGALRM",
      "SIGTERM",
      "SIGCHLD",
      "SIGCONT",
      "SIGSTOP",
      "SIGTSTP",
      "SIGTTIN",
      "SIGTTOU",
      "SIGURG",
      "SIGXCPU",
      "SIGXFSZ",
      "SIGVTALRM",
      "SIGPROF",
      "SIGWINCH",
      "SIGIO",
      "SIGINFO",
      "SIGSYS",
      "UV_FS_SYMLINK_DIR",
      "UV_FS_SYMLINK_JUNCTION",
      "O_RDONLY",
      "O_WRONLY",
      "O_RDWR",
      "UV_DIRENT_UNKNOWN",
      "UV_DIRENT_FILE",
      "UV_DIRENT_DIR",
      "UV_DIRENT_LINK",
      "UV_DIRENT_FIFO",
      "UV_DIRENT_SOCKET",
      "UV_DIRENT_CHAR",
      "UV_DIRENT_BLOCK",
      "EXTENSIONLESS_FORMAT_JAVASCRIPT",
      "EXTENSIONLESS_FORMAT_WASM",
      "S_IFMT",
      "S_IFREG",
      "S_IFDIR",
      "S_IFCHR",
      "S_IFBLK",
      "S_IFIFO",
      "S_IFLNK",
      "S_IFSOCK",
      "O_CREAT",
      "O_EXCL",
      "UV_FS_O_FILEMAP",
      "O_NOCTTY",
      "O_TRUNC",
      "O_APPEND",
      "O_DIRECTORY",
      "O_NOFOLLOW",
      "O_SYNC",
      "O_DSYNC",
      "O_SYMLINK",
      "O_NONBLOCK",
      "S_IRWXU",
      "S_IRUSR",
      "S_IWUSR",
      "S_IXUSR",
      "S_IRWXG",
      "S_IRGRP",
      "S_IWGRP",
      "S_IXGRP",
      "S_IRWXO",
      "S_IROTH",
      "S_IWOTH",
      "S_IXOTH",
      "F_OK",
      "R_OK",
      "W_OK",
      "X_OK",
      "UV_FS_COPYFILE_EXCL",
      "COPYFILE_EXCL",
      "UV_FS_COPYFILE_FICLONE",
      "COPYFILE_FICLONE",
      "UV_FS_COPYFILE_FICLONE_FORCE",
      "COPYFILE_FICLONE_FORCE",
      "OPENSSL_VERSION_NUMBER",
      "SSL_OP_ALL",
      "SSL_OP_ALLOW_NO_DHE_KEX",
      "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION",
      "SSL_OP_CIPHER_SERVER_PREFERENCE",
      "SSL_OP_CISCO_ANYCONNECT",
      "SSL_OP_COOKIE_EXCHANGE",
      "SSL_OP_CRYPTOPRO_TLSEXT_BUG",
      "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS",
      "SSL_OP_LEGACY_SERVER_CONNECT",
      "SSL_OP_NO_COMPRESSION",
      "SSL_OP_NO_ENCRYPT_THEN_MAC",
      "SSL_OP_NO_QUERY_MTU",
      "SSL_OP_NO_RENEGOTIATION",
      "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION",
      "SSL_OP_NO_SSLv2",
      "SSL_OP_NO_SSLv3",
      "SSL_OP_NO_TICKET",
      "SSL_OP_NO_TLSv1",
      "SSL_OP_NO_TLSv1_1",
      "SSL_OP_NO_TLSv1_2",
      "SSL_OP_NO_TLSv1_3",
      "SSL_OP_PRIORITIZE_CHACHA",
      "SSL_OP_TLS_ROLLBACK_BUG",
      "ENGINE_METHOD_RSA",
      "ENGINE_METHOD_DSA",
      "ENGINE_METHOD_DH",
      "ENGINE_METHOD_RAND",
      "ENGINE_METHOD_EC",
      "ENGINE_METHOD_CIPHERS",
      "ENGINE_METHOD_DIGESTS",
      "ENGINE_METHOD_PKEY_METHS",
      "ENGINE_METHOD_PKEY_ASN1_METHS",
      "ENGINE_METHOD_ALL",
      "ENGINE_METHOD_NONE",
      "DH_CHECK_P_NOT_SAFE_PRIME",
      "DH_CHECK_P_NOT_PRIME",
      "DH_UNABLE_TO_CHECK_GENERATOR",
      "DH_NOT_SUITABLE_GENERATOR",
      "RSA_PKCS1_PADDING",
      "RSA_NO_PADDING",
      "RSA_PKCS1_OAEP_PADDING",
      "RSA_X931_PADDING",
      "RSA_PKCS1_PSS_PADDING",
      "RSA_PSS_SALTLEN_DIGEST",
      "RSA_PSS_SALTLEN_MAX_SIGN",
      "RSA_PSS_SALTLEN_AUTO",
      "defaultCoreCipherList",
      "TLS1_VERSION",
      "TLS1_1_VERSION",
      "TLS1_2_VERSION",
      "TLS1_3_VERSION",
      "POINT_CONVERSION_COMPRESSED",
      "POINT_CONVERSION_UNCOMPRESSED",
      "POINT_CONVERSION_HYBRID",
      "defaultCipherList"
    ]),
    hasDefaultExport: true
  },
  crypto: {
    namedExports: /* @__PURE__ */ new Set([
      "checkPrime",
      "checkPrimeSync",
      "createCipheriv",
      "createDecipheriv",
      "createDiffieHellman",
      "createDiffieHellmanGroup",
      "createECDH",
      "createHash",
      "createHmac",
      "createPrivateKey",
      "createPublicKey",
      "createSecretKey",
      "createSign",
      "createVerify",
      "diffieHellman",
      "generatePrime",
      "generatePrimeSync",
      "getCiphers",
      "getCipherInfo",
      "getCurves",
      "getDiffieHellman",
      "getHashes",
      "hkdf",
      "hkdfSync",
      "pbkdf2",
      "pbkdf2Sync",
      "generateKeyPair",
      "generateKeyPairSync",
      "generateKey",
      "generateKeySync",
      "privateDecrypt",
      "privateEncrypt",
      "publicDecrypt",
      "publicEncrypt",
      "randomBytes",
      "randomFill",
      "randomFillSync",
      "randomInt",
      "randomUUID",
      "scrypt",
      "scryptSync",
      "sign",
      "setEngine",
      "timingSafeEqual",
      "getFips",
      "setFips",
      "verify",
      "hash",
      "Certificate",
      "Cipher",
      "Cipheriv",
      "Decipher",
      "Decipheriv",
      "DiffieHellman",
      "DiffieHellmanGroup",
      "ECDH",
      "Hash",
      "Hmac",
      "KeyObject",
      "Sign",
      "Verify",
      "X509Certificate",
      "secureHeapUsed",
      "constants",
      "webcrypto",
      "subtle",
      "getRandomValues"
    ]),
    hasDefaultExport: true
  },
  dgram: {
    namedExports: /* @__PURE__ */ new Set(["createSocket", "Socket"]),
    hasDefaultExport: true
  },
  diagnostics_channel: {
    namedExports: /* @__PURE__ */ new Set(["channel", "hasSubscribers", "subscribe", "tracingChannel", "unsubscribe", "Channel"]),
    hasDefaultExport: true
  },
  dns: {
    namedExports: /* @__PURE__ */ new Set([
      "lookup",
      "lookupService",
      "Resolver",
      "getDefaultResultOrder",
      "setDefaultResultOrder",
      "setServers",
      "ADDRCONFIG",
      "ALL",
      "V4MAPPED",
      "NODATA",
      "FORMERR",
      "SERVFAIL",
      "NOTFOUND",
      "NOTIMP",
      "REFUSED",
      "BADQUERY",
      "BADNAME",
      "BADFAMILY",
      "BADRESP",
      "CONNREFUSED",
      "TIMEOUT",
      "EOF",
      "FILE",
      "NOMEM",
      "DESTRUCTION",
      "BADSTR",
      "BADFLAGS",
      "NONAME",
      "BADHINTS",
      "NOTINITIALIZED",
      "LOADIPHLPAPI",
      "ADDRGETNETWORKPARAMS",
      "CANCELLED",
      "getServers",
      "resolve",
      "resolve4",
      "resolve6",
      "resolveAny",
      "resolveCaa",
      "resolveCname",
      "resolveMx",
      "resolveNaptr",
      "resolveNs",
      "resolvePtr",
      "resolveSoa",
      "resolveSrv",
      "resolveTxt",
      "reverse",
      "promises"
    ]),
    hasDefaultExport: true
  },
  "dns/promises": {
    namedExports: /* @__PURE__ */ new Set([
      "lookup",
      "lookupService",
      "Resolver",
      "getDefaultResultOrder",
      "setDefaultResultOrder",
      "setServers",
      "NODATA",
      "FORMERR",
      "SERVFAIL",
      "NOTFOUND",
      "NOTIMP",
      "REFUSED",
      "BADQUERY",
      "BADNAME",
      "BADFAMILY",
      "BADRESP",
      "CONNREFUSED",
      "TIMEOUT",
      "EOF",
      "FILE",
      "NOMEM",
      "DESTRUCTION",
      "BADSTR",
      "BADFLAGS",
      "NONAME",
      "BADHINTS",
      "NOTINITIALIZED",
      "LOADIPHLPAPI",
      "ADDRGETNETWORKPARAMS",
      "CANCELLED",
      "getServers",
      "resolve",
      "resolve4",
      "resolve6",
      "resolveAny",
      "resolveCaa",
      "resolveCname",
      "resolveMx",
      "resolveNaptr",
      "resolveNs",
      "resolvePtr",
      "resolveSoa",
      "resolveSrv",
      "resolveTxt",
      "reverse"
    ]),
    hasDefaultExport: true
  },
  domain: {
    namedExports: /* @__PURE__ */ new Set(["Domain", "createDomain", "create", "active"]),
    hasDefaultExport: true
  },
  events: {
    namedExports: /* @__PURE__ */ new Set([]),
    hasDefaultExport: true
  },
  fs: {
    namedExports: /* @__PURE__ */ new Set([
      "appendFile",
      "appendFileSync",
      "access",
      "accessSync",
      "chown",
      "chownSync",
      "chmod",
      "chmodSync",
      "close",
      "closeSync",
      "copyFile",
      "copyFileSync",
      "cp",
      "cpSync",
      "createReadStream",
      "createWriteStream",
      "exists",
      "existsSync",
      "fchown",
      "fchownSync",
      "fchmod",
      "fchmodSync",
      "fdatasync",
      "fdatasyncSync",
      "fstat",
      "fstatSync",
      "fsync",
      "fsyncSync",
      "ftruncate",
      "ftruncateSync",
      "futimes",
      "futimesSync",
      "glob",
      "globSync",
      "lchown",
      "lchownSync",
      "lchmod",
      "lchmodSync",
      "link",
      "linkSync",
      "lstat",
      "lstatSync",
      "lutimes",
      "lutimesSync",
      "mkdir",
      "mkdirSync",
      "mkdtemp",
      "mkdtempSync",
      "open",
      "openSync",
      "openAsBlob",
      "readdir",
      "readdirSync",
      "read",
      "readSync",
      "readv",
      "readvSync",
      "readFile",
      "readFileSync",
      "readlink",
      "readlinkSync",
      "realpath",
      "realpathSync",
      "rename",
      "renameSync",
      "rm",
      "rmSync",
      "rmdir",
      "rmdirSync",
      "stat",
      "statfs",
      "statSync",
      "statfsSync",
      "symlink",
      "symlinkSync",
      "truncate",
      "truncateSync",
      "unwatchFile",
      "unlink",
      "unlinkSync",
      "utimes",
      "utimesSync",
      "watch",
      "watchFile",
      "writeFile",
      "writeFileSync",
      "write",
      "writeSync",
      "writev",
      "writevSync",
      "Dirent",
      "Stats",
      "ReadStream",
      "WriteStream",
      "FileReadStream",
      "FileWriteStream",
      "Dir",
      "opendir",
      "opendirSync",
      "F_OK",
      "R_OK",
      "W_OK",
      "X_OK",
      "constants",
      "promises"
    ]),
    hasDefaultExport: true
  },
  "fs/promises": {
    namedExports: /* @__PURE__ */ new Set([
      "access",
      "copyFile",
      "cp",
      "glob",
      "open",
      "opendir",
      "rename",
      "truncate",
      "rm",
      "rmdir",
      "mkdir",
      "readdir",
      "readlink",
      "symlink",
      "lstat",
      "stat",
      "statfs",
      "link",
      "unlink",
      "chmod",
      "lchmod",
      "lchown",
      "chown",
      "utimes",
      "lutimes",
      "realpath",
      "mkdtemp",
      "writeFile",
      "appendFile",
      "readFile",
      "watch",
      "constants"
    ]),
    hasDefaultExport: true
  },
  http: {
    namedExports: /* @__PURE__ */ new Set([
      "METHODS",
      "STATUS_CODES",
      "Agent",
      "ClientRequest",
      "IncomingMessage",
      "OutgoingMessage",
      "Server",
      "ServerResponse",
      "createServer",
      "validateHeaderName",
      "validateHeaderValue",
      "get",
      "request",
      "setMaxIdleHTTPParsers",
      "maxHeaderSize",
      "globalAgent",
      "WebSocket",
      "CloseEvent",
      "MessageEvent"
    ]),
    hasDefaultExport: true
  },
  http2: {
    namedExports: /* @__PURE__ */ new Set([
      "connect",
      "constants",
      "createServer",
      "createSecureServer",
      "getDefaultSettings",
      "getPackedSettings",
      "getUnpackedSettings",
      "performServerHandshake",
      "sensitiveHeaders",
      "Http2ServerRequest",
      "Http2ServerResponse"
    ]),
    hasDefaultExport: true
  },
  https: {
    namedExports: /* @__PURE__ */ new Set(["Agent", "globalAgent", "Server", "createServer", "get", "request"]),
    hasDefaultExport: true
  },
  inspector: {
    namedExports: /* @__PURE__ */ new Set(["open", "close", "url", "waitForDebugger", "console", "Session", "Network"]),
    hasDefaultExport: true
  },
  "inspector/promises": {
    namedExports: /* @__PURE__ */ new Set(["open", "close", "url", "waitForDebugger", "console", "Session", "Network"]),
    hasDefaultExport: true
  },
  module: {
    namedExports: /* @__PURE__ */ new Set([]),
    hasDefaultExport: true
  },
  net: {
    namedExports: /* @__PURE__ */ new Set([
      "BlockList",
      "SocketAddress",
      "connect",
      "createConnection",
      "createServer",
      "isIP",
      "isIPv4",
      "isIPv6",
      "Server",
      "Socket",
      "Stream",
      "getDefaultAutoSelectFamily",
      "setDefaultAutoSelectFamily",
      "getDefaultAutoSelectFamilyAttemptTimeout",
      "setDefaultAutoSelectFamilyAttemptTimeout"
    ]),
    hasDefaultExport: true
  },
  os: {
    namedExports: /* @__PURE__ */ new Set([
      "arch",
      "availableParallelism",
      "cpus",
      "endianness",
      "freemem",
      "getPriority",
      "homedir",
      "hostname",
      "loadavg",
      "networkInterfaces",
      "platform",
      "release",
      "setPriority",
      "tmpdir",
      "totalmem",
      "type",
      "userInfo",
      "uptime",
      "version",
      "machine",
      "constants",
      "EOL",
      "devNull"
    ]),
    hasDefaultExport: true
  },
  path: {
    namedExports: /* @__PURE__ */ new Set([
      "resolve",
      "normalize",
      "isAbsolute",
      "join",
      "relative",
      "toNamespacedPath",
      "dirname",
      "basename",
      "extname",
      "format",
      "parse",
      "matchesGlob",
      "sep",
      "delimiter",
      "win32",
      "posix"
    ]),
    hasDefaultExport: true
  },
  "path/posix": {
    namedExports: /* @__PURE__ */ new Set([
      "resolve",
      "normalize",
      "isAbsolute",
      "join",
      "relative",
      "toNamespacedPath",
      "dirname",
      "basename",
      "extname",
      "format",
      "parse",
      "matchesGlob",
      "sep",
      "delimiter",
      "win32",
      "posix"
    ]),
    hasDefaultExport: true
  },
  "path/win32": {
    namedExports: /* @__PURE__ */ new Set([
      "resolve",
      "normalize",
      "isAbsolute",
      "join",
      "relative",
      "toNamespacedPath",
      "dirname",
      "basename",
      "extname",
      "format",
      "parse",
      "matchesGlob",
      "sep",
      "delimiter",
      "win32",
      "posix"
    ]),
    hasDefaultExport: true
  },
  perf_hooks: {
    namedExports: /* @__PURE__ */ new Set([
      "Performance",
      "PerformanceEntry",
      "PerformanceMark",
      "PerformanceMeasure",
      "PerformanceObserver",
      "PerformanceObserverEntryList",
      "PerformanceResourceTiming",
      "monitorEventLoopDelay",
      "createHistogram",
      "performance",
      "constants"
    ]),
    hasDefaultExport: true
  },
  process: {
    namedExports: /* @__PURE__ */ new Set([
      "version",
      "versions",
      "arch",
      "platform",
      "release",
      "moduleLoadList",
      "binding",
      "domain",
      "exitCode",
      "config",
      "dlopen",
      "uptime",
      "getActiveResourcesInfo",
      "reallyExit",
      "loadEnvFile",
      "cpuUsage",
      "resourceUsage",
      "memoryUsage",
      "constrainedMemory",
      "availableMemory",
      "kill",
      "exit",
      "finalization",
      "hrtime",
      "openStdin",
      "getuid",
      "geteuid",
      "getgid",
      "getegid",
      "getgroups",
      "allowedNodeEnvironmentFlags",
      "assert",
      "features",
      "setUncaughtExceptionCaptureCallback",
      "hasUncaughtExceptionCaptureCallback",
      "emitWarning",
      "nextTick",
      "sourceMapsEnabled",
      "setSourceMapsEnabled",
      "getBuiltinModule",
      "stdout",
      "stdin",
      "stderr",
      "abort",
      "umask",
      "chdir",
      "cwd",
      "initgroups",
      "setgroups",
      "setegid",
      "seteuid",
      "setgid",
      "setuid",
      "env",
      "title",
      "argv",
      "execArgv",
      "pid",
      "ppid",
      "execPath",
      "debugPort",
      "argv0",
      "report"
    ]),
    hasDefaultExport: true
  },
  punycode: {
    namedExports: /* @__PURE__ */ new Set(["version", "ucs2", "decode", "encode", "toASCII", "toUnicode"]),
    hasDefaultExport: true
  },
  querystring: {
    namedExports: /* @__PURE__ */ new Set(["unescapeBuffer", "unescape", "escape", "stringify", "encode", "parse", "decode"]),
    hasDefaultExport: true
  },
  readline: {
    namedExports: /* @__PURE__ */ new Set(["Interface", "clearLine", "clearScreenDown", "createInterface", "cursorTo", "emitKeypressEvents", "moveCursor", "promises"]),
    hasDefaultExport: true
  },
  "readline/promises": {
    namedExports: /* @__PURE__ */ new Set(["Interface", "Readline", "createInterface"]),
    hasDefaultExport: true
  },
  repl: {
    namedExports: /* @__PURE__ */ new Set(["start", "writer", "REPLServer", "REPL_MODE_SLOPPY", "REPL_MODE_STRICT", "Recoverable", "builtinModules"]),
    hasDefaultExport: true
  },
  stream: {
    namedExports: /* @__PURE__ */ new Set([]),
    hasDefaultExport: true
  },
  "stream/consumers": {
    namedExports: /* @__PURE__ */ new Set(["arrayBuffer", "blob", "buffer", "text", "json"]),
    hasDefaultExport: true
  },
  "stream/promises": {
    namedExports: /* @__PURE__ */ new Set(["finished", "pipeline"]),
    hasDefaultExport: true
  },
  "stream/web": {
    namedExports: /* @__PURE__ */ new Set([
      "ReadableStream",
      "ReadableStreamDefaultReader",
      "ReadableStreamBYOBReader",
      "ReadableStreamBYOBRequest",
      "ReadableByteStreamController",
      "ReadableStreamDefaultController",
      "TransformStream",
      "TransformStreamDefaultController",
      "WritableStream",
      "WritableStreamDefaultWriter",
      "WritableStreamDefaultController",
      "ByteLengthQueuingStrategy",
      "CountQueuingStrategy",
      "TextEncoderStream",
      "TextDecoderStream",
      "CompressionStream",
      "DecompressionStream"
    ]),
    hasDefaultExport: true
  },
  string_decoder: {
    namedExports: /* @__PURE__ */ new Set(["StringDecoder"]),
    hasDefaultExport: true
  },
  timers: {
    namedExports: /* @__PURE__ */ new Set(["setTimeout", "clearTimeout", "setImmediate", "clearImmediate", "setInterval", "clearInterval", "active", "unenroll", "enroll", "promises"]),
    hasDefaultExport: true
  },
  "timers/promises": {
    namedExports: /* @__PURE__ */ new Set(["setTimeout", "setImmediate", "setInterval", "scheduler"]),
    hasDefaultExport: true
  },
  tls: {
    namedExports: /* @__PURE__ */ new Set([
      "CLIENT_RENEG_LIMIT",
      "CLIENT_RENEG_WINDOW",
      "DEFAULT_CIPHERS",
      "DEFAULT_ECDH_CURVE",
      "DEFAULT_MIN_VERSION",
      "DEFAULT_MAX_VERSION",
      "getCiphers",
      "rootCertificates",
      "convertALPNProtocols",
      "checkServerIdentity",
      "createSecureContext",
      "SecureContext",
      "TLSSocket",
      "Server",
      "createServer",
      "connect",
      "createSecurePair"
    ]),
    hasDefaultExport: true
  },
  trace_events: {
    namedExports: /* @__PURE__ */ new Set(["createTracing", "getEnabledCategories"]),
    hasDefaultExport: true
  },
  tty: {
    namedExports: /* @__PURE__ */ new Set(["isatty", "ReadStream", "WriteStream"]),
    hasDefaultExport: true
  },
  url: {
    namedExports: /* @__PURE__ */ new Set([
      "Url",
      "parse",
      "resolve",
      "resolveObject",
      "format",
      "URL",
      "URLSearchParams",
      "domainToASCII",
      "domainToUnicode",
      "pathToFileURL",
      "fileURLToPath",
      "urlToHttpOptions"
    ]),
    hasDefaultExport: true
  },
  util: {
    namedExports: /* @__PURE__ */ new Set([
      "callbackify",
      "debug",
      "debuglog",
      "deprecate",
      "format",
      "styleText",
      "formatWithOptions",
      "getCallSite",
      "getSystemErrorMap",
      "getSystemErrorName",
      "inherits",
      "inspect",
      "isArray",
      "isBoolean",
      "isBuffer",
      "isDeepStrictEqual",
      "isNull",
      "isNullOrUndefined",
      "isNumber",
      "isString",
      "isSymbol",
      "isUndefined",
      "isRegExp",
      "isObject",
      "isDate",
      "isError",
      "isFunction",
      "isPrimitive",
      "log",
      "promisify",
      "stripVTControlCharacters",
      "toUSVString",
      "transferableAbortSignal",
      "transferableAbortController",
      "aborted",
      "types",
      "parseEnv",
      "parseArgs",
      "TextDecoder",
      "TextEncoder",
      "MIMEType",
      "MIMEParams"
    ]),
    hasDefaultExport: true
  },
  "util/types": {
    namedExports: /* @__PURE__ */ new Set([
      "isExternal",
      "isDate",
      "isArgumentsObject",
      "isBigIntObject",
      "isBooleanObject",
      "isNumberObject",
      "isStringObject",
      "isSymbolObject",
      "isNativeError",
      "isRegExp",
      "isAsyncFunction",
      "isGeneratorFunction",
      "isGeneratorObject",
      "isPromise",
      "isMap",
      "isSet",
      "isMapIterator",
      "isSetIterator",
      "isWeakMap",
      "isWeakSet",
      "isArrayBuffer",
      "isDataView",
      "isSharedArrayBuffer",
      "isProxy",
      "isModuleNamespaceObject",
      "isAnyArrayBuffer",
      "isBoxedPrimitive",
      "isArrayBufferView",
      "isTypedArray",
      "isUint8Array",
      "isUint8ClampedArray",
      "isUint16Array",
      "isUint32Array",
      "isInt8Array",
      "isInt16Array",
      "isInt32Array",
      "isFloat32Array",
      "isFloat64Array",
      "isBigInt64Array",
      "isBigUint64Array",
      "isKeyObject",
      "isCryptoKey"
    ]),
    hasDefaultExport: true
  },
  v8: {
    namedExports: /* @__PURE__ */ new Set([
      "cachedDataVersionTag",
      "getHeapSnapshot",
      "getHeapStatistics",
      "getHeapSpaceStatistics",
      "getHeapCodeStatistics",
      "setFlagsFromString",
      "Serializer",
      "Deserializer",
      "DefaultSerializer",
      "DefaultDeserializer",
      "deserialize",
      "takeCoverage",
      "stopCoverage",
      "serialize",
      "writeHeapSnapshot",
      "promiseHooks",
      "queryObjects",
      "startupSnapshot",
      "setHeapSnapshotNearHeapLimit",
      "GCProfiler"
    ]),
    hasDefaultExport: true
  },
  vm: {
    namedExports: /* @__PURE__ */ new Set([
      "Script",
      "createContext",
      "createScript",
      "runInContext",
      "runInNewContext",
      "runInThisContext",
      "isContext",
      "compileFunction",
      "measureMemory",
      "constants"
    ]),
    hasDefaultExport: true
  },
  wasi: {
    namedExports: /* @__PURE__ */ new Set(["WASI"]),
    hasDefaultExport: true
  },
  worker_threads: {
    namedExports: /* @__PURE__ */ new Set([
      "isMainThread",
      "MessagePort",
      "MessageChannel",
      "markAsUntransferable",
      "isMarkedAsUntransferable",
      "moveMessagePortToContext",
      "receiveMessageOnPort",
      "resourceLimits",
      "postMessageToThread",
      "threadId",
      "SHARE_ENV",
      "Worker",
      "parentPort",
      "workerData",
      "BroadcastChannel",
      "setEnvironmentData",
      "getEnvironmentData"
    ]),
    hasDefaultExport: true
  },
  zlib: {
    namedExports: /* @__PURE__ */ new Set([
      "crc32",
      "Deflate",
      "Inflate",
      "Gzip",
      "Gunzip",
      "DeflateRaw",
      "InflateRaw",
      "Unzip",
      "BrotliCompress",
      "BrotliDecompress",
      "deflate",
      "deflateSync",
      "gzip",
      "gzipSync",
      "deflateRaw",
      "deflateRawSync",
      "unzip",
      "unzipSync",
      "inflate",
      "inflateSync",
      "gunzip",
      "gunzipSync",
      "inflateRaw",
      "inflateRawSync",
      "brotliCompress",
      "brotliCompressSync",
      "brotliDecompress",
      "brotliDecompressSync",
      "createDeflate",
      "createInflate",
      "createDeflateRaw",
      "createInflateRaw",
      "createGzip",
      "createGunzip",
      "createUnzip",
      "createBrotliCompress",
      "createBrotliDecompress",
      "constants",
      "codes"
    ]),
    hasDefaultExport: true
  }
};

// src/transformer/util/transform-module-specifier.ts
import path3 from "crosspath";
function determineNewExtension(currentExtension) {
  switch (currentExtension) {
    case ".ts":
    case ".tsx":
    case ".d.ts":
    case ".d.mts":
    case ".js":
    case ".jsx":
    case ".cjs":
    case ".cjsx":
    case ".cts":
      return ".js";
    case ".mjs":
    case ".mts":
    case ".mjsx":
    case ".d.cts":
      return ".mjs";
    default:
      return currentExtension;
  }
}
function transformModuleSpecifier(moduleSpecifier, { context, parent, resolvedModuleSpecifier }) {
  if (path3.extname(moduleSpecifier) !== "" || resolvedModuleSpecifier == null) {
    return moduleSpecifier;
  }
  switch (context.preserveModuleSpecifiers) {
    case "always":
      return moduleSpecifier;
    case "never":
      break;
    case "external":
      if (isExternalLibrary(moduleSpecifier)) {
        return moduleSpecifier;
      }
      break;
    case "internal":
      if (!isExternalLibrary(moduleSpecifier)) {
        return moduleSpecifier;
      }
      break;
    default:
      if (context.preserveModuleSpecifiers(moduleSpecifier)) {
        return moduleSpecifier;
      }
  }
  return setExtension(ensureHasLeadingDotAndPosix(path3.relative(path3.dirname(parent), resolvedModuleSpecifier)), determineNewExtension(path3.extname(resolvedModuleSpecifier)));
}

// src/transformer/util/is-require-call.ts
function isRequireCall(inputExpression, sourceFile, context) {
  const { typescript } = context;
  const callExpression = walkThroughFillerNodes(inputExpression, typescript);
  if (!typescript.isCallExpression(callExpression)) return { match: false };
  const expression = walkThroughFillerNodes(callExpression.expression, typescript);
  if (!typescript.isIdentifier(expression) || expression.text !== "require") return { match: false };
  const [firstArgument] = callExpression.arguments;
  if (firstArgument == null) return { match: false };
  const moduleSpecifier = typescript.isStringLiteralLike(firstArgument) ? firstArgument.text : void 0;
  const resolvedModuleSpecifier = moduleSpecifier == null ? void 0 : resolvePath({
    ...context,
    id: moduleSpecifier,
    parent: sourceFile.fileName
  });
  const resolvedModuleSpecifierText = resolvedModuleSpecifier == null || isBuiltInModule(resolvedModuleSpecifier) ? void 0 : context.fileSystem.safeReadFileSync(resolvedModuleSpecifier)?.toString();
  if (moduleSpecifier == null || resolvedModuleSpecifier == null || resolvedModuleSpecifierText == null) {
    return {
      match: true,
      moduleSpecifier,
      transformedModuleSpecifier: moduleSpecifier,
      resolvedModuleSpecifier: void 0,
      resolvedModuleSpecifierText: void 0
    };
  } else {
    return {
      match: true,
      transformedModuleSpecifier: transformModuleSpecifier(moduleSpecifier, { resolvedModuleSpecifier, context, parent: sourceFile.fileName }),
      moduleSpecifier,
      resolvedModuleSpecifier,
      resolvedModuleSpecifierText
    };
  }
}

// src/transformer/util/find-node-up.ts
function findNodeUp(from, nodeCb, breakWhen) {
  let current = from;
  while (current.parent != null) {
    current = current.parent;
    if (breakWhen?.(current)) return void 0;
    if (nodeCb(current)) return current;
  }
  return void 0;
}

// src/transformer/util/is-statement.ts
function isStatement(node, typescript) {
  return typescript.isStatementButNotDeclaration(node);
}

// src/transformer/util/is-declaration.ts
function isDeclaration(node, typescript) {
  return typescript.isDeclaration(node);
}

// src/transformer/util/is-statement-or-declaration.ts
function isStatementOrDeclaration(node, typescript) {
  return isStatement(node, typescript) || isDeclaration(node, typescript);
}

// src/transformer/util/generate-name-from-module-specifier.ts
import { camelCase } from "@wessberg/stringutil";
import path4 from "crosspath";
function generateNameFromModuleSpecifier(moduleSpecifier) {
  const { name } = path4.parse(moduleSpecifier);
  return camelCase(name);
}

// src/transformer/util/get-module-exports-from-require-data-in-context.ts
function getModuleExportsFromRequireDataInContext(data, context) {
  if (!data.match) return void 0;
  const { typescript } = context;
  const { moduleSpecifier, resolvedModuleSpecifierText, resolvedModuleSpecifier } = data;
  if (moduleSpecifier == null) {
    return void 0;
  }
  let moduleExports;
  if (resolvedModuleSpecifier == null && isBuiltInModule(moduleSpecifier)) {
    moduleExports = BUILT_IN_MODULE_MAP[moduleSpecifier];
  } else if (resolvedModuleSpecifier != null) {
    if (isJsonModule(resolvedModuleSpecifier)) {
      moduleExports = {
        withValue: "json",
        hasDefaultExport: true,
        namedExports: /* @__PURE__ */ new Set()
      };
    } else {
      moduleExports = context.getModuleExportsForPath(resolvedModuleSpecifier);
      if (moduleExports == null) {
        moduleExports = context.transformSourceFile(
          typescript.createSourceFile(resolvedModuleSpecifier, resolvedModuleSpecifierText, typescript.ScriptTarget.ESNext, true, typescript.ScriptKind.TS),
          {
            ...context,
            onlyExports: true
          }
        ).exports;
      }
    }
  }
  return moduleExports;
}

// src/transformer/util/should-debug.ts
function shouldDebug(debug, sourceFile) {
  if (debug == null) return false;
  if (typeof debug === "boolean") return debug;
  if (sourceFile == null) return true;
  if (typeof debug === "string") return sourceFile.fileName === debug;
  else return debug(sourceFile.fileName);
}

// src/transformer/util/maybe-generate-import-attributes.ts
function maybeGenerateImportAttributes(context, moduleSpecifier, withValue) {
  if (withValue == null) return void 0;
  const { factory, importAttributes } = context;
  if (importAttributes === false || typeof importAttributes === "function" && !importAttributes(moduleSpecifier)) {
    return void 0;
  }
  if (!("createImportAttributes" in context.typescript.factory)) {
    context.logger.warn(
      `The current version of TypeScript (v${context.typescript.version}) does not support Import Attributes. No Import Attributes will be added for the module with specifier '${moduleSpecifier}' in the transformed code. To remove this warning, either disable import attributes or update to TypeScript v5.3 or newer.`
    );
  }
  return factory.createImportAttributes(factory.createNodeArray([factory.createImportAttribute(factory.createIdentifier("type"), factory.createStringLiteral(withValue))]));
}

// src/transformer/visitor/visit/visit-call-expression.ts
function visitCallExpression({ node, childContinuation, sourceFile, context }) {
  if (context.onlyExports) {
    return childContinuation(node);
  }
  const requireData = isRequireCall(node, sourceFile, context);
  const { typescript, factory } = context;
  if (!requireData.match) {
    return childContinuation(node);
  }
  const { moduleSpecifier, transformedModuleSpecifier } = requireData;
  if (moduleSpecifier == null || transformedModuleSpecifier == null) {
    return void 0;
  }
  const moduleExports = getModuleExportsFromRequireDataInContext(requireData, context);
  const expressionStatementParent = findNodeUp(
    node,
    typescript.isExpressionStatement,
    (currentNode) => typescript.isBinaryExpression(currentNode) || typescript.isCallExpression(currentNode) || typescript.isNewExpression(currentNode)
  );
  if (moduleExports == null || moduleExports.namedExports.size === 0 || expressionStatementParent != null && !moduleExports.hasDefaultExport) {
    if (expressionStatementParent != null) {
      if (!context.isModuleSpecifierImportedWithoutLocals(moduleSpecifier)) {
        context.addImport(
          factory.createImportDeclaration(
            void 0,
            void 0,
            factory.createStringLiteral(transformedModuleSpecifier),
            maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports?.withValue)
          ),
          moduleSpecifier
        );
      }
      return void 0;
    } else {
      if (context.hasLocalForDefaultImportFromModule(moduleSpecifier)) {
        const local = context.getLocalForDefaultImportFromModule(moduleSpecifier);
        return factory.createIdentifier(local);
      } else {
        const identifier = factory.createIdentifier(context.getFreeIdentifier(generateNameFromModuleSpecifier(moduleSpecifier)));
        const importClause = factory.createImportClause(false, identifier, void 0);
        context.addImport(
          factory.createImportDeclaration(
            void 0,
            importClause,
            factory.createStringLiteral(transformedModuleSpecifier),
            maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports?.withValue)
          ),
          moduleSpecifier
        );
        return identifier;
      }
    }
  }
  const elementOrPropertyAccessExpressionParent = findNodeUp(
    node,
    (child) => typescript.isElementAccessExpression(child) || typescript.isPropertyAccessExpression(child),
    (nextNode) => isStatementOrDeclaration(nextNode, typescript)
  );
  if (elementOrPropertyAccessExpressionParent != null) {
    let rightValue;
    if (typescript.isPropertyAccessExpression(elementOrPropertyAccessExpressionParent)) {
      rightValue = elementOrPropertyAccessExpressionParent.name.text;
    } else {
      if (typescript.isStringLiteralLike(elementOrPropertyAccessExpressionParent.argumentExpression)) {
        rightValue = elementOrPropertyAccessExpressionParent.argumentExpression.text;
      }
    }
    if (rightValue != null) {
      if (!moduleExports.namedExports.has(rightValue)) {
        let identifier;
        if (moduleExports.hasDefaultExport && context.hasLocalForDefaultImportFromModule(moduleSpecifier)) {
          identifier = factory.createIdentifier(context.getLocalForDefaultImportFromModule(moduleSpecifier));
        } else if (!moduleExports.hasDefaultExport && context.hasLocalForNamespaceImportFromModule(moduleSpecifier)) {
          identifier = factory.createIdentifier(context.getLocalForNamespaceImportFromModule(moduleSpecifier));
        } else {
          identifier = factory.createIdentifier(context.getFreeIdentifier(generateNameFromModuleSpecifier(moduleSpecifier)));
          context.addImport(
            factory.createImportDeclaration(
              void 0,
              moduleExports.hasDefaultExport ? (
                // Import the default if it has any (or if we don't know if it has)
                factory.createImportClause(false, identifier, void 0)
              ) : (
                // Otherwise, import the entire namespace
                factory.createImportClause(false, void 0, factory.createNamespaceImport(identifier))
              ),
              factory.createStringLiteral(transformedModuleSpecifier),
              maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports.withValue)
            ),
            moduleSpecifier
          );
        }
        const objectLiteralProperties = [
          identifier.text !== rightValue ? factory.createPropertyAssignment(rightValue, factory.createIdentifier(identifier.text)) : factory.createShorthandPropertyAssignment(factory.createIdentifier(identifier.text))
        ];
        return factory.createObjectLiteralExpression(objectLiteralProperties);
      } else {
        const importBindingPropertyName = rightValue;
        let importBindingName;
        if (context.hasLocalForNamedImportPropertyNameFromModule(importBindingPropertyName, moduleSpecifier)) {
          importBindingName = context.getLocalForNamedImportPropertyNameFromModule(importBindingPropertyName, moduleSpecifier);
        } else if (!moduleExports.hasDefaultExport && context.hasLocalForNamespaceImportFromModule(moduleSpecifier)) {
          importBindingName = context.getLocalForNamespaceImportFromModule(moduleSpecifier);
        } else {
          importBindingName = context.getFreeIdentifier(importBindingPropertyName);
          const namedImports = factory.createNamedImports([
            importBindingPropertyName === importBindingName ? (
              // If the property name is free within the context, don't alias the import
              factory.createImportSpecifier(false, void 0, factory.createIdentifier(importBindingPropertyName))
            ) : (
              // Otherwise, import it aliased by another name that is free within the context
              factory.createImportSpecifier(false, factory.createIdentifier(importBindingPropertyName), factory.createIdentifier(importBindingName))
            )
          ]);
          const importClause = factory.createImportClause(false, void 0, namedImports);
          context.addImport(
            factory.createImportDeclaration(
              void 0,
              importClause,
              factory.createStringLiteral(transformedModuleSpecifier),
              maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports.withValue)
            ),
            moduleSpecifier
          );
        }
        if (expressionStatementParent == null) {
          const objectLiteralProperties = [
            importBindingName !== rightValue ? factory.createPropertyAssignment(rightValue, factory.createIdentifier(importBindingName)) : factory.createShorthandPropertyAssignment(factory.createIdentifier(importBindingName))
          ];
          return factory.createObjectLiteralExpression(objectLiteralProperties);
        } else {
          return void 0;
        }
      }
    }
  }
  const variableDeclarationParent = findNodeUp(node, typescript.isVariableDeclaration, (nextNode) => isStatement(nextNode, typescript));
  if (variableDeclarationParent != null) {
    if (typescript.isIdentifier(variableDeclarationParent.name)) {
      if (moduleExports.hasDefaultExport && context.hasLocalForDefaultImportFromModule(moduleSpecifier)) {
        const local = context.getLocalForDefaultImportFromModule(moduleSpecifier);
        return factory.createIdentifier(local);
      } else if (!moduleExports.hasDefaultExport && context.hasLocalForNamespaceImportFromModule(moduleSpecifier)) {
        const local = context.getLocalForNamespaceImportFromModule(moduleSpecifier);
        return factory.createIdentifier(local);
      } else {
        const identifier = factory.createIdentifier(context.getFreeIdentifier(generateNameFromModuleSpecifier(moduleSpecifier)));
        context.addImport(
          factory.createImportDeclaration(
            void 0,
            moduleExports.hasDefaultExport ? (
              // Import the default if it has any (or if we don't know if it has)
              factory.createImportClause(false, identifier, void 0)
            ) : (
              // Otherwise, import the entire namespace
              factory.createImportClause(false, void 0, factory.createNamespaceImport(identifier))
            ),
            factory.createStringLiteral(transformedModuleSpecifier),
            maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports.withValue)
          ),
          moduleSpecifier
        );
        return identifier;
      }
    } else if (typescript.isObjectBindingPattern(variableDeclarationParent.name)) {
      const importSpecifiers = [];
      const skippedImportSpecifiers = [];
      for (const element of variableDeclarationParent.name.elements) {
        if (element.propertyName == null && typescript.isIdentifier(element.name)) {
          if (moduleExports.namedExports.has(element.name.text)) {
            if (context.hasLocalForNamedImportPropertyNameFromModule(element.name.text, moduleSpecifier)) {
              const local = context.getLocalForNamedImportPropertyNameFromModule(element.name.text, moduleSpecifier);
              skippedImportSpecifiers.push(
                local === element.name.text ? factory.createImportSpecifier(false, void 0, factory.createIdentifier(local)) : factory.createImportSpecifier(false, factory.createIdentifier(element.name.text), factory.createIdentifier(local))
              );
            } else if (context.isIdentifierFree(element.name.text)) {
              context.addLocal(element.name.text);
              importSpecifiers.push(factory.createImportSpecifier(false, void 0, factory.createIdentifier(element.name.text)));
            } else {
              const alias = context.getFreeIdentifier(element.name.text);
              importSpecifiers.push(factory.createImportSpecifier(false, factory.createIdentifier(element.name.text), factory.createIdentifier(alias)));
            }
          }
        } else if (element.propertyName != null && typescript.isIdentifier(element.propertyName)) {
          if (context.isIdentifierFree(element.propertyName.text)) {
            context.addLocal(element.propertyName.text);
            importSpecifiers.push(factory.createImportSpecifier(false, void 0, factory.createIdentifier(element.propertyName.text)));
          } else {
            const alias = context.getFreeIdentifier(element.propertyName.text);
            importSpecifiers.push(factory.createImportSpecifier(false, factory.createIdentifier(element.propertyName.text), factory.createIdentifier(alias)));
          }
        }
      }
      if (importSpecifiers.length + skippedImportSpecifiers.length !== variableDeclarationParent.name.elements.length) {
        if (moduleExports.hasDefaultExport && context.hasLocalForDefaultImportFromModule(moduleSpecifier)) {
          const local = context.getLocalForDefaultImportFromModule(moduleSpecifier);
          return factory.createIdentifier(local);
        } else if (!moduleExports.hasDefaultExport && context.hasLocalForNamespaceImportFromModule(moduleSpecifier)) {
          const local = context.getLocalForNamespaceImportFromModule(moduleSpecifier);
          return factory.createIdentifier(local);
        } else {
          const identifier = factory.createIdentifier(context.getFreeIdentifier(generateNameFromModuleSpecifier(moduleSpecifier)));
          context.addImport(
            factory.createImportDeclaration(
              void 0,
              moduleExports.hasDefaultExport ? (
                // Import the default if it has any (or if we don't know if it has)
                factory.createImportClause(false, identifier, void 0)
              ) : (
                // Otherwise, import the entire namespace
                factory.createImportClause(false, void 0, factory.createNamespaceImport(identifier))
              ),
              factory.createStringLiteral(transformedModuleSpecifier),
              maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports.withValue)
            ),
            moduleSpecifier
          );
          return identifier;
        }
      } else {
        if (importSpecifiers.length > 0) {
          context.addImport(
            factory.createImportDeclaration(
              void 0,
              factory.createImportClause(false, void 0, factory.createNamedImports(importSpecifiers)),
              factory.createStringLiteral(transformedModuleSpecifier),
              maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports.withValue)
            ),
            moduleSpecifier
          );
        }
        const objectLiteralProperties = [...importSpecifiers, ...skippedImportSpecifiers].map(
          (specifier) => specifier.propertyName != null ? factory.createPropertyAssignment(specifier.propertyName.text, factory.createIdentifier(specifier.name.text)) : factory.createShorthandPropertyAssignment(factory.createIdentifier(specifier.name.text))
        );
        return factory.createObjectLiteralExpression(objectLiteralProperties);
      }
    }
  }
  const binaryExpressionParent = findNodeUp(node, typescript.isBinaryExpression, (nextNode) => isStatement(nextNode, typescript));
  if (binaryExpressionParent != null && binaryExpressionParent.operatorToken.kind === typescript.SyntaxKind.EqualsToken && (typescript.isPropertyAccessExpression(walkThroughFillerNodes(binaryExpressionParent.left, typescript)) || typescript.isElementAccessExpression(walkThroughFillerNodes(binaryExpressionParent.left, typescript)))) {
    if (moduleExports.hasDefaultExport && context.hasLocalForDefaultImportFromModule(moduleSpecifier)) {
      const local = context.getLocalForDefaultImportFromModule(moduleSpecifier);
      return factory.createIdentifier(local);
    } else if (!moduleExports.hasDefaultExport && context.hasLocalForNamespaceImportFromModule(moduleSpecifier)) {
      const local = context.getLocalForNamespaceImportFromModule(moduleSpecifier);
      return factory.createIdentifier(local);
    } else {
      const identifier = factory.createIdentifier(context.getFreeIdentifier(generateNameFromModuleSpecifier(moduleSpecifier)));
      context.addImport(
        factory.createImportDeclaration(
          void 0,
          moduleExports.hasDefaultExport ? (
            // Import the default if it has any (or if we don't know if it has)
            factory.createImportClause(false, identifier, void 0)
          ) : (
            // Otherwise, import the entire namespace
            factory.createImportClause(false, void 0, factory.createNamespaceImport(identifier))
          ),
          factory.createStringLiteral(transformedModuleSpecifier),
          maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports.withValue)
        ),
        moduleSpecifier
      );
      return identifier;
    }
  }
  const callExpressionParent = findNodeUp(node, typescript.isCallExpression, (nextNode) => isStatementOrDeclaration(nextNode, typescript));
  if (callExpressionParent != null) {
    if (moduleExports.hasDefaultExport && context.hasLocalForDefaultImportFromModule(moduleSpecifier)) {
      const local = context.getLocalForDefaultImportFromModule(moduleSpecifier);
      return factory.createIdentifier(local);
    } else if (!moduleExports.hasDefaultExport && context.hasLocalForNamespaceImportFromModule(moduleSpecifier)) {
      const local = context.getLocalForNamespaceImportFromModule(moduleSpecifier);
      return factory.createIdentifier(local);
    } else {
      const identifier = factory.createIdentifier(context.getFreeIdentifier(generateNameFromModuleSpecifier(moduleSpecifier)));
      context.addImport(
        factory.createImportDeclaration(
          void 0,
          moduleExports.hasDefaultExport ? (
            // Import the default if it has any (or if we don't know if it has)
            factory.createImportClause(false, identifier, void 0)
          ) : (
            // Otherwise, import the entire namespace
            factory.createImportClause(false, void 0, factory.createNamespaceImport(identifier))
          ),
          factory.createStringLiteral(transformedModuleSpecifier),
          maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports.withValue)
        ),
        moduleSpecifier
      );
      return identifier;
    }
  }
  if (shouldDebug(context.debug)) {
    throw new TypeError(`Could not handle require() call`);
  } else {
    return node;
  }
}

// src/transformer/util/get-exports-data.ts
function getExportsData(expression, exportsName = "exports", typescript) {
  expression = walkThroughFillerNodes(expression, typescript);
  if (typescript.isIdentifier(expression)) {
    if (expression.text === exportsName) {
      return {};
    } else {
      return void 0;
    }
  } else if (typescript.isPropertyAccessExpression(expression)) {
    const left = walkThroughFillerNodes(expression.expression, typescript);
    const right = expression.name;
    if (typescript.isIdentifier(left)) {
      if (left.text === "module" && right.text === exportsName) {
        return {};
      } else if (left.text === exportsName) {
        return {
          property: right.text
        };
      } else {
        return void 0;
      }
    } else {
      const leftData = getExportsData(left, exportsName, typescript);
      if (leftData == null) {
        return void 0;
      } else {
        return {
          ...leftData,
          property: right.text
        };
      }
    }
  } else if (typescript.isElementAccessExpression(expression)) {
    const left = walkThroughFillerNodes(expression.expression, typescript);
    const right = walkThroughFillerNodes(expression.argumentExpression, typescript);
    if (!typescript.isStringLiteralLike(right)) return void 0;
    if (typescript.isIdentifier(left)) {
      if (left.text === "module" && right.text === exportsName) {
        return {};
      } else if (left.text === exportsName) {
        return {
          property: right.text
        };
      } else {
        return void 0;
      }
    } else {
      const leftData = getExportsData(left, exportsName, typescript);
      if (leftData == null) {
        return void 0;
      } else {
        return {
          ...leftData,
          property: right.text
        };
      }
    }
  } else {
    return void 0;
  }
}

// src/transformer/util/is-named-declaration.ts
function isNamedDeclaration(node, typescript) {
  if (typescript.isPropertyAccessExpression(node)) return false;
  return "name" in node && node.name != null;
}

// src/transformer/util/ensure-node-has-export-modifier.ts
function ensureNodeHasExportModifier(node, context) {
  const { typescript, factory } = context;
  const declarationName = typescript.getNameOfDeclaration(node);
  if (declarationName != null && typescript.isIdentifier(declarationName)) {
    if (context.isLocalExported(declarationName.text)) {
      return node;
    }
    context.markLocalAsExported(declarationName.text);
  }
  if (hasExportModifier(node, typescript) || !canHaveModifiers(node, typescript)) {
    return node;
  }
  const newModifiers = addExportModifier(node, typescript, factory);
  return context.factory.replaceModifiers(
    node,
    newModifiers.filter((modifier) => typescript.isModifier(modifier))
  );
}

// src/transformer/util/node-contains-super.ts
function nodeContainsSuper(node, typescript) {
  if (node.kind === typescript.SyntaxKind.ThisKeyword) return true;
  return typescript.forEachChild(node, (nextNode) => nodeContainsSuper(nextNode, typescript)) === true;
}

// src/transformer/util/is-expression.ts
function isExpression(node, typescript) {
  try {
    return typescript.isExpressionNode(node) || typescript.isIdentifier(node);
  } catch {
    return false;
  }
}

// src/transformer/util/get-locals-for-binding-name.ts
function getLocalsForBindingName(name, typescript) {
  if (typescript.isIdentifier(name)) {
    return [name.text];
  } else if (typescript.isObjectBindingPattern(name)) {
    const locals = [];
    for (const element of name.elements) {
      locals.push(...getLocalsForBindingName(element.name, typescript));
    }
    return locals;
  } else {
    const locals = [];
    for (const element of name.elements) {
      if (typescript.isOmittedExpression(element)) continue;
      locals.push(...getLocalsForBindingName(element.name, typescript));
    }
    return locals;
  }
}

// src/transformer/visitor/visit/visit-binary-expression.ts
function visitBinaryExpression({ node, sourceFile, context, continuation }) {
  const { typescript, factory } = context;
  const exportsData = getExportsData(node.left, context.exportsName, typescript);
  const right = walkThroughFillerNodes(node.right, typescript);
  if (exportsData == null) return node;
  if (node.operatorToken.kind === typescript.SyntaxKind.EqualsToken) {
    const variableDeclarationParent = findNodeUp(node, typescript.isVariableDeclaration);
    const [firstLocalForVariableDeclarationParent] = variableDeclarationParent == null ? [] : getLocalsForBindingName(variableDeclarationParent.name, typescript);
    const variableDeclarationLocal = firstLocalForVariableDeclarationParent != null ? factory.createIdentifier(firstLocalForVariableDeclarationParent) : void 0;
    if (exportsData.property == null || exportsData.property === "default") {
      if (typescript.isObjectLiteralExpression(right)) {
        if (right.properties.length === 0 || variableDeclarationLocal != null) {
          const continuationResult = continuation(node.right);
          if (continuationResult == null || isArray(continuationResult) || !isExpression(continuationResult, typescript)) {
            return void 0;
          }
          const exportedSymbol = variableDeclarationLocal ?? continuationResult;
          if (!context.isDefaultExported) {
            context.markDefaultAsExported();
            context.addTrailingStatements(factory.createExportAssignment(void 0, false, exportedSymbol));
          }
          return variableDeclarationParent != null ? node.right : void 0;
        }
        const statements = [];
        let moduleExportsIdentifierName;
        const elements = [];
        for (const property of right.properties) {
          const propertyName = property.name == null ? void 0 : typescript.isLiteralExpression(property.name) || typescript.isIdentifier(property.name) || typescript.isPrivateIdentifier(property.name) ? property.name.text : typescript.isLiteralExpression(property.name.expression) ? property.name.expression.text : void 0;
          if (propertyName == null || typescript.isSetAccessorDeclaration(property) || typescript.isGetAccessorDeclaration(property) || context.isLocalExported(propertyName)) {
            elements.push(property);
            continue;
          }
          if (typescript.isShorthandPropertyAssignment(property)) {
            context.markLocalAsExported(propertyName);
            elements.push(factory.createShorthandPropertyAssignment(propertyName, property.objectAssignmentInitializer));
            const namedExports = factory.createNamedExports([factory.createExportSpecifier(false, void 0, propertyName)]);
            statements.push(factory.createExportDeclaration(void 0, false, namedExports, void 0));
          } else if (typescript.isPropertyAssignment(property) && typescript.isIdentifier(property.initializer)) {
            context.markLocalAsExported(propertyName);
            elements.push(factory.createPropertyAssignment(propertyName, factory.createIdentifier(property.initializer.text)));
            const namedExports = factory.createNamedExports([
              propertyName === property.initializer.text ? factory.createExportSpecifier(false, void 0, propertyName) : factory.createExportSpecifier(false, property.initializer.text, propertyName)
            ]);
            statements.push(factory.createExportDeclaration(void 0, false, namedExports, void 0));
          } else if (context.isIdentifierFree(propertyName) && typescript.isPropertyAssignment(property) && !nodeContainsSuper(property.initializer, typescript)) {
            context.addLocal(propertyName);
            elements.push(factory.createShorthandPropertyAssignment(propertyName));
            statements.push(
              factory.createVariableStatement(
                [factory.createModifier(typescript.SyntaxKind.ExportKeyword)],
                factory.createVariableDeclarationList([factory.createVariableDeclaration(propertyName, void 0, void 0, property.initializer)], typescript.NodeFlags.Const)
              )
            );
          } else if (context.isIdentifierFree(propertyName) && typescript.isMethodDeclaration(property) && typescript.isIdentifier(property.name) && !nodeContainsSuper(property, typescript)) {
            context.addLocal(propertyName);
            elements.push(factory.createShorthandPropertyAssignment(propertyName));
            statements.push(
              factory.createFunctionDeclaration(
                addExportModifier(property, typescript, factory),
                property.asteriskToken,
                property.name,
                property.typeParameters,
                property.parameters,
                property.type,
                property.body
              )
            );
          } else if (context.isIdentifierFree(propertyName)) {
            context.addLocal(propertyName);
            elements.push(property);
            if (moduleExportsIdentifierName == null) {
              moduleExportsIdentifierName = context.getFreeIdentifier("moduleExports");
            }
            context.markLocalAsExported(propertyName);
            statements.push(
              factory.createVariableStatement(
                [factory.createModifier(typescript.SyntaxKind.ExportKeyword)],
                factory.createVariableDeclarationList(
                  [
                    factory.createVariableDeclaration(
                      propertyName,
                      void 0,
                      void 0,
                      factory.createPropertyAccessExpression(factory.createIdentifier(moduleExportsIdentifierName), propertyName)
                    )
                  ],
                  typescript.NodeFlags.Const
                )
              )
            );
          } else {
            elements.push(property);
          }
        }
        if (moduleExportsIdentifierName != null) {
          statements.push(
            factory.createVariableStatement(
              void 0,
              factory.createVariableDeclarationList(
                [factory.createVariableDeclaration(moduleExportsIdentifierName, void 0, void 0, factory.createObjectLiteralExpression(elements, true))],
                typescript.NodeFlags.Const
              )
            )
          );
          if (!context.isDefaultExported) {
            statements.push(factory.createExportAssignment(void 0, false, factory.createIdentifier(moduleExportsIdentifierName)));
            context.markDefaultAsExported();
          }
        } else if (!context.isDefaultExported) {
          const defaultExportInitializer = factory.createObjectLiteralExpression(elements, true);
          statements.push(factory.createExportAssignment(void 0, false, defaultExportInitializer));
        }
        context.addTrailingStatements(...statements);
        return void 0;
      } else {
        const requireData = isRequireCall(node.right, sourceFile, context);
        if (!requireData.match) {
          if (!context.isDefaultExported) {
            context.markDefaultAsExported();
            const continuationResult = continuation(node.right);
            if (continuationResult == null || isArray(continuationResult) || !isExpression(continuationResult, typescript)) {
              return void 0;
            } else {
              const replacementNode = variableDeclarationParent != null ? continuationResult : void 0;
              const exportedSymbol = variableDeclarationLocal ?? continuationResult;
              context.addTrailingStatements(factory.createExportAssignment(void 0, false, exportedSymbol));
              return replacementNode;
            }
          }
          return void 0;
        }
        const { transformedModuleSpecifier } = requireData;
        if (transformedModuleSpecifier == null) {
          if (shouldDebug(context.debug)) {
            throw new TypeError(`Could not handle re-export from require() call. The module specifier wasn't statically analyzable`);
          } else {
            return void 0;
          }
        } else {
          const moduleExports = getModuleExportsFromRequireDataInContext(requireData, context);
          const moduleSpecifierExpression = factory.createStringLiteral(transformedModuleSpecifier);
          if (!context.isDefaultExported && (moduleExports == null || moduleExports.hasDefaultExport)) {
            context.markDefaultAsExported();
            const namedExports = factory.createNamedExports([factory.createExportSpecifier(false, void 0, "default")]);
            context.addTrailingStatements(factory.createExportDeclaration(void 0, false, namedExports, moduleSpecifierExpression));
            return void 0;
          } else {
            context.addTrailingStatements(factory.createExportDeclaration(void 0, false, void 0, moduleSpecifierExpression));
            return void 0;
          }
        }
      }
    } else if (variableDeclarationLocal != null) {
      const local = exportsData.property;
      const continuationResult = continuation(node.right);
      if (continuationResult == null || isArray(continuationResult) || !isExpression(continuationResult, typescript) && !typescript.isIdentifier(continuationResult)) {
        return void 0;
      }
      const namedExports = factory.createNamedExports([
        local === variableDeclarationLocal.text ? factory.createExportSpecifier(false, void 0, factory.createIdentifier(local)) : factory.createExportSpecifier(false, variableDeclarationLocal.text, factory.createIdentifier(local))
      ]);
      context.addTrailingStatements(factory.createExportDeclaration(void 0, false, namedExports));
      return continuationResult;
    } else if (typescript.isIdentifier(right)) {
      const local = exportsData.property;
      if (!context.isLocalExported(local)) {
        const namedExports = factory.createNamedExports([
          local === right.text ? factory.createExportSpecifier(false, void 0, factory.createIdentifier(local)) : factory.createExportSpecifier(false, right.text, factory.createIdentifier(local))
        ]);
        context.markLocalAsExported(local);
        context.addTrailingStatements(factory.createExportDeclaration(void 0, false, namedExports));
      }
      return void 0;
    } else if (isNamedDeclaration(right, typescript) && right.name != null && typescript.isIdentifier(right.name) && exportsData.property === right.name.text) {
      context.addTrailingStatements(ensureNodeHasExportModifier(right, context));
      return void 0;
    } else {
      const continuationResult = continuation(node.right);
      if (continuationResult == null || Array.isArray(continuationResult)) {
        return void 0;
      }
      if (!context.isLocalExported(exportsData.property)) {
        context.markLocalAsExported(exportsData.property);
        if (!isArray(continuationResult) && typescript.isIdentifier(continuationResult)) {
          const namedExports = factory.createNamedExports([
            continuationResult.text === exportsData.property ? factory.createExportSpecifier(false, void 0, factory.createIdentifier(exportsData.property)) : factory.createExportSpecifier(false, factory.createIdentifier(continuationResult.text), factory.createIdentifier(exportsData.property))
          ]);
          context.addTrailingStatements(factory.createExportDeclaration(void 0, false, namedExports, void 0));
        } else {
          const freeIdentifier = context.getFreeIdentifier(exportsData.property);
          if (freeIdentifier === exportsData.property) {
            context.addTrailingStatements(
              factory.createVariableStatement(
                [factory.createModifier(typescript.SyntaxKind.ExportKeyword)],
                factory.createVariableDeclarationList(
                  [factory.createVariableDeclaration(exportsData.property, void 0, void 0, continuationResult)],
                  typescript.NodeFlags.Const
                )
              )
            );
          } else {
            const namedExports = factory.createNamedExports([factory.createExportSpecifier(false, freeIdentifier, exportsData.property)]);
            context.addTrailingStatements(
              factory.createVariableStatement(
                void 0,
                factory.createVariableDeclarationList(
                  [factory.createVariableDeclaration(freeIdentifier, void 0, void 0, continuationResult)],
                  typescript.NodeFlags.Const
                )
              ),
              factory.createExportDeclaration(void 0, false, namedExports, void 0)
            );
          }
        }
      }
      return void 0;
    }
  }
  return node;
}

// src/transformer/util/will-be-reassigned.ts
function willReassignIdentifier(identifier, node, typescript) {
  const result = typescript.forEachChild(node, (nextNode) => {
    if (typescript.isBinaryExpression(nextNode) && nextNode.operatorToken.kind === typescript.SyntaxKind.EqualsToken && typescript.isIdentifier(nextNode.left) && nextNode.left.text === identifier) {
      return true;
    }
    if (willReassignIdentifier(identifier, nextNode, typescript)) {
      return true;
    }
    return;
  });
  return result ?? false;
}

// src/transformer/visitor/visit/visit-variable-declaration.ts
function visitVariableDeclaration({ node, childContinuation, sourceFile, context }) {
  if (context.onlyExports || node.initializer == null) {
    return childContinuation(node);
  }
  const { typescript, factory } = context;
  const initializer = walkThroughFillerNodes(node.initializer, typescript);
  const statement = findNodeUp(node, typescript.isVariableStatement, (n) => typescript.isBlock(n) || typescript.isSourceFile(n));
  if (!typescript.isCallExpression(initializer)) {
    return childContinuation(node);
  }
  const requireData = isRequireCall(initializer, sourceFile, context);
  if (!requireData.match) {
    return childContinuation(node);
  }
  const { moduleSpecifier, transformedModuleSpecifier } = requireData;
  if (moduleSpecifier == null || transformedModuleSpecifier == null) {
    return childContinuation(node);
  }
  const moduleExports = getModuleExportsFromRequireDataInContext(requireData, context);
  if (typescript.isIdentifier(node.name)) {
    if ((moduleExports == null || moduleExports.hasDefaultExport) && context.hasLocalForDefaultImportFromModule(moduleSpecifier)) {
      return childContinuation(node);
    } else if (moduleExports != null && !moduleExports.hasDefaultExport && context.hasLocalForNamespaceImportFromModule(moduleSpecifier)) {
      return childContinuation(node);
    } else if (statement != null && hasExportModifier(statement, typescript)) {
      const moduleSpecifierExpression = factory.createStringLiteral(transformedModuleSpecifier);
      if (moduleExports == null || moduleExports.hasDefaultExport) {
        const exportClause = factory.createNamedExports([
          factory.createExportSpecifier(false, node.name.text === "default" ? void 0 : factory.createIdentifier("default"), factory.createIdentifier(node.name.text))
        ]);
        context.addTrailingStatements(factory.createExportDeclaration(void 0, false, exportClause, moduleSpecifierExpression));
        return void 0;
      } else if (factory.createNamespaceExport != null) {
        const exportClause = factory.createNamespaceExport(factory.createIdentifier(node.name.text));
        context.addTrailingStatements(factory.createExportDeclaration(void 0, false, exportClause, moduleSpecifierExpression));
        return void 0;
      } else {
        context.addImport(
          factory.createImportDeclaration(
            void 0,
            factory.createImportClause(false, void 0, factory.createNamespaceImport(factory.createIdentifier(node.name.text))),
            moduleSpecifierExpression,
            maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports.withValue)
          ),
          moduleSpecifier
        );
        const exportClause = factory.createNamedExports([factory.createExportSpecifier(false, void 0, factory.createIdentifier(node.name.text))]);
        context.addTrailingStatements(factory.createExportDeclaration(void 0, false, exportClause));
        return void 0;
      }
    } else {
      const willReassign = willReassignIdentifier(node.name.text, sourceFile, typescript);
      const newName = willReassign ? context.getFreeIdentifier(node.name.text, true) : node.name.text;
      context.addImport(
        factory.createImportDeclaration(
          void 0,
          moduleExports == null || moduleExports.hasDefaultExport ? (
            // Import the default if it has any (or if we don't know if it has)
            factory.createImportClause(false, factory.createIdentifier(newName), void 0)
          ) : (
            // Otherwise, import the entire namespace
            factory.createImportClause(false, void 0, factory.createNamespaceImport(factory.createIdentifier(newName)))
          ),
          factory.createStringLiteral(transformedModuleSpecifier),
          maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports?.withValue)
        ),
        moduleSpecifier
      );
      if (willReassign) {
        context.addLeadingStatements(
          factory.createVariableStatement(
            void 0,
            factory.createVariableDeclarationList(
              [factory.createVariableDeclaration(node.name.text, void 0, void 0, factory.createIdentifier(newName))],
              typescript.NodeFlags.Let
            )
          )
        );
      }
      return void 0;
    }
  } else if (moduleExports != null && typescript.isObjectBindingPattern(node.name)) {
    const importSpecifiers = [];
    for (const element of node.name.elements) {
      if (element.propertyName == null && typescript.isIdentifier(element.name)) {
        if (!moduleExports.namedExports.has(element.name.text)) {
          return childContinuation(node);
        }
        importSpecifiers.push(factory.createImportSpecifier(false, void 0, factory.createIdentifier(element.name.text)));
      } else if (element.propertyName != null && typescript.isIdentifier(element.propertyName) && typescript.isIdentifier(element.name)) {
        if (!moduleExports.namedExports.has(element.propertyName.text)) {
          return childContinuation(node);
        }
        importSpecifiers.push(factory.createImportSpecifier(false, factory.createIdentifier(element.propertyName.text), factory.createIdentifier(element.name.text)));
      } else {
        return childContinuation(node);
      }
    }
    if (importSpecifiers.length > 0) {
      const importSpecifiersThatWillBeReassigned = importSpecifiers.filter((importSpecifier) => willReassignIdentifier(importSpecifier.name.text, sourceFile, typescript));
      const otherImportSpecifiers = importSpecifiers.filter((importSpecifier) => !importSpecifiersThatWillBeReassigned.includes(importSpecifier));
      for (const importSpecifier of importSpecifiersThatWillBeReassigned) {
        const propertyName = importSpecifier.propertyName ?? importSpecifier.name;
        const newName = context.getFreeIdentifier(importSpecifier.name.text, true);
        const namedImports = factory.createNamedImports([factory.createImportSpecifier(false, factory.createIdentifier(propertyName.text), factory.createIdentifier(newName))]);
        context.addImport(
          factory.createImportDeclaration(
            void 0,
            factory.createImportClause(false, void 0, namedImports),
            factory.createStringLiteral(transformedModuleSpecifier),
            maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports.withValue)
          ),
          moduleSpecifier
        );
        context.addLeadingStatements(
          factory.createVariableStatement(
            void 0,
            factory.createVariableDeclarationList(
              [factory.createVariableDeclaration(importSpecifier.name.text, void 0, void 0, factory.createIdentifier(newName))],
              typescript.NodeFlags.Let
            )
          )
        );
      }
      if (otherImportSpecifiers.length > 0) {
        context.addImport(
          factory.createImportDeclaration(
            void 0,
            factory.createImportClause(false, void 0, factory.createNamedImports(otherImportSpecifiers)),
            factory.createStringLiteral(transformedModuleSpecifier),
            maybeGenerateImportAttributes(context, transformedModuleSpecifier, moduleExports.withValue)
          ),
          moduleSpecifier
        );
      }
      return void 0;
    }
  }
  return childContinuation(node);
}

// src/transformer/visitor/visit/is-not-emitted-statement.ts
function isNotEmittedStatement(node, typescript) {
  return node.kind === typescript.SyntaxKind.NotEmittedStatement;
}

// src/transformer/visitor/visit/visit-variable-declaration-list.ts
function visitVariableDeclarationList({ node, childContinuation, context }) {
  if (context.onlyExports) {
    return childContinuation(node);
  }
  const { typescript, factory } = context;
  const continuationResult = childContinuation(node);
  if (continuationResult == null || isArray(continuationResult) || !typescript.isVariableDeclarationList(continuationResult)) {
    return continuationResult;
  }
  const remainingDeclarations = continuationResult.declarations.filter((declaration) => !isNotEmittedStatement(declaration, typescript));
  if (remainingDeclarations.length === 0) return continuationResult;
  return factory.updateVariableDeclarationList(node, remainingDeclarations);
}

// src/transformer/util/get-best-body-in-scope.ts
function hasExportAssignments(node, exportsName, typescript) {
  const result = typescript.forEachChild(node, (nextNode) => {
    if (isExpression(nextNode, typescript)) {
      if (getExportsData(nextNode, exportsName, typescript) != null) return true;
    }
    if (hasExportAssignments(nextNode, exportsName, typescript)) {
      return true;
    }
    return;
  });
  return result ?? false;
}
function getBestBodyInScope({ node, context }) {
  const { typescript, factory } = context;
  if (!typescript.isSourceFile(node)) {
    return node;
  }
  const [firstStatement] = node.statements;
  if (firstStatement == null || !typescript.isExpressionStatement(firstStatement)) return node;
  const expression = walkThroughFillerNodes(firstStatement.expression, typescript);
  if (!typescript.isCallExpression(expression)) return node;
  const expressionExpression = walkThroughFillerNodes(expression.expression, typescript);
  if (!typescript.isFunctionExpression(expressionExpression)) return node;
  if (expression.arguments.length < 2) return node;
  let [, secondArgument] = expression.arguments;
  if (secondArgument == null) return node;
  secondArgument = walkThroughFillerNodes(secondArgument, typescript);
  if (!typescript.isFunctionExpression(secondArgument)) return node;
  if (secondArgument.parameters.length < 1) return node;
  const [firstBodyParameter] = secondArgument.parameters;
  if (firstBodyParameter == null || !typescript.isIdentifier(firstBodyParameter.name)) return node;
  if (hasExportAssignments(secondArgument.body, firstBodyParameter.name.text, typescript)) {
    context.exportsName = firstBodyParameter.name.text;
    return factory.updateSourceFile(
      node,
      [...secondArgument.body.statements, ...node.statements.slice(1)],
      node.isDeclarationFile,
      node.referencedFiles,
      node.typeReferenceDirectives,
      node.hasNoDefaultLib,
      node.libReferenceDirectives
    );
  }
  return node;
}

// src/transformer/visitor/visit/visit-node.ts
function visitNode(options) {
  const { typescript } = options.context;
  const bestNode = getBestBodyInScope(options);
  if (bestNode != null && bestNode !== options.node) {
    return options.childContinuation(bestNode);
  }
  if (typescript.isVariableDeclarationList(options.node)) {
    return visitVariableDeclarationList(options);
  } else if (typescript.isVariableDeclaration(options.node)) {
    return visitVariableDeclaration(options);
  } else if (typescript.isBinaryExpression(options.node)) {
    return visitBinaryExpression(options);
  } else if (typescript.isCallExpression(options.node)) {
    return visitCallExpression(options);
  }
  return options.childContinuation(options.node);
}

// src/transformer/transform-source-file.ts
import { check } from "reserved-words";

// src/transformer/util/should-skip-emit.ts
function shouldSkipEmit(node, typescript) {
  if (node == null) return true;
  if (isArray(node)) return node.some((otherNode) => shouldSkipEmit(otherNode, typescript));
  if (typescript.isSourceFile(node)) return false;
  if (typescript.isBlock(node)) return false;
  return isNotEmittedStatement(node, typescript) || Boolean(typescript.forEachChild(node, (nextNode) => shouldSkipEmit(nextNode, typescript)));
}

// src/transformer/visitor/visit/visit-import-declaration.ts
function visitImportDeclaration({ node, context }) {
  if (!context.typescript.isStringLiteralLike(node.moduleSpecifier)) return void 0;
  context.addImport(node, node.moduleSpecifier.text, true);
  return void 0;
}

// src/transformer/visitor/visit/visit-export-declaration.ts
function visitExportDeclaration({ node, context }) {
  if (node.exportClause != null && context.typescript.isNamedExports(node.exportClause)) {
    for (const element of node.exportClause.elements) {
      if (element.name.text === "default") {
        context.markDefaultAsExported();
      } else {
        context.markLocalAsExported(element.name.text);
      }
    }
  }
  return void 0;
}

// src/transformer/visitor/visit/visit-export-assignment.ts
function visitExportAssignment({ context }) {
  context.markDefaultAsExported();
  return void 0;
}

// src/transformer/visitor/visit/visit-import-and-export-declarations.ts
function visitImportAndExportDeclarations(options) {
  const { typescript } = options.context;
  if (typescript.isImportDeclaration(options.node)) {
    return visitImportDeclaration(options);
  } else if (typescript.isExportDeclaration(options.node)) {
    return visitExportDeclaration(options);
  } else if (typescript.isExportAssignment(options.node)) {
    return visitExportAssignment(options);
  } else if (hasDefaultExportModifier(options.node, typescript)) {
    options.context.markDefaultAsExported();
  } else if (hasExportModifier(options.node, typescript)) {
    if (isDeclaration(options.node, typescript)) {
      const declarationName = typescript.getNameOfDeclaration(options.node);
      if (declarationName != null && typescript.isIdentifier(declarationName)) {
        options.context.markLocalAsExported(declarationName.text);
      }
    } else if (typescript.isVariableStatement(options.node)) {
      for (const declaration of options.node.declarationList.declarations) {
        for (const local of getLocalsForBindingName(declaration.name, typescript)) {
          options.context.markLocalAsExported(local);
        }
      }
    }
  }
  return options.childContinuation(options.node);
}

// src/transformer/transform-source-file.ts
import path5 from "crosspath";
function transformSourceFile(sourceFile, context) {
  if (!context.onlyExports && !sourceFile.text.includes("require") && !sourceFile.text.includes("exports")) {
    return { sourceFile, exports: { namedExports: /* @__PURE__ */ new Set(), hasDefaultExport: false } };
  }
  const { typescript, factory, transformationContext } = context;
  const visitorContext = (() => {
    const imports = /* @__PURE__ */ new Map();
    const leadingStatements = [];
    const trailingStatements = [];
    const moduleExportsMap = /* @__PURE__ */ new Map();
    const localsMap = sourceFile.locals;
    const locals = localsMap == null ? /* @__PURE__ */ new Set() : new Set(localsMap.keys());
    const exportedLocals = /* @__PURE__ */ new Set();
    let isDefaultExported = false;
    const addImport = (declaration, originalModuleSpecifier, noEmit = false) => {
      imports.set(declaration, { originalModuleSpecifier, noEmit });
    };
    const markLocalAsExported = (local) => {
      exportedLocals.add(local);
    };
    const isLocalExported = (local) => exportedLocals.has(local);
    const markDefaultAsExported = () => {
      isDefaultExported = true;
    };
    const addLocal = (local) => {
      locals.add(local);
    };
    const getImportDeclarationWithModuleSpecifier = (moduleSpecifier) => [...imports.entries()].find(([, { originalModuleSpecifier }]) => originalModuleSpecifier === moduleSpecifier)?.[0];
    const isModuleSpecifierImportedWithoutLocals = (moduleSpecifier) => {
      const matchingDeclaration = getImportDeclarationWithModuleSpecifier(moduleSpecifier);
      if (matchingDeclaration == null) return false;
      return matchingDeclaration.importClause == null || matchingDeclaration.importClause.name == null && matchingDeclaration.importClause.namedBindings == null;
    };
    const getLocalForDefaultImportFromModule = (moduleSpecifier) => {
      const matchingDeclaration = getImportDeclarationWithModuleSpecifier(moduleSpecifier);
      if (matchingDeclaration == null) return void 0;
      if (matchingDeclaration.importClause?.name == null) return void 0;
      return matchingDeclaration.importClause.name.text;
    };
    const hasLocalForDefaultImportFromModule = (moduleSpecifier) => getLocalForDefaultImportFromModule(moduleSpecifier) != null;
    const getLocalForNamespaceImportFromModule = (moduleSpecifier) => {
      const matchingDeclaration = getImportDeclarationWithModuleSpecifier(moduleSpecifier);
      if (matchingDeclaration == null) {
        return void 0;
      }
      if (matchingDeclaration.importClause?.namedBindings == null || !typescript.isNamespaceImport(matchingDeclaration.importClause.namedBindings)) {
        return void 0;
      }
      return matchingDeclaration.importClause.namedBindings.name.text;
    };
    const hasLocalForNamespaceImportFromModule = (moduleSpecifier) => getLocalForNamespaceImportFromModule(moduleSpecifier) != null;
    const getLocalForNamedImportPropertyNameFromModule = (propertyName, moduleSpecifier) => {
      const matchingDeclaration = getImportDeclarationWithModuleSpecifier(moduleSpecifier);
      if (matchingDeclaration == null) return void 0;
      if (matchingDeclaration.importClause?.namedBindings == null || !typescript.isNamedImports(matchingDeclaration.importClause.namedBindings)) {
        return void 0;
      }
      for (const element of matchingDeclaration.importClause.namedBindings.elements) {
        if (element.propertyName != null && element.propertyName.text === propertyName) return element.name.text;
        else if (element.propertyName == null && element.name.text === propertyName) return element.name.text;
      }
      return void 0;
    };
    const hasLocalForNamedImportPropertyNameFromModule = (propertyName, moduleSpecifier) => getLocalForNamedImportPropertyNameFromModule(propertyName, moduleSpecifier) != null;
    const addTrailingStatements = (...statements) => {
      trailingStatements.push(...statements);
    };
    const addLeadingStatements = (...statements) => {
      leadingStatements.push(...statements);
    };
    const isIdentifierFree = (identifier) => (
      // It should not be part of locals of the module already
      !locals.has(identifier) && // It should not be a reserved word in any environment
      !check(identifier, "es3", true) && !check(identifier, "es5", true) && !check(identifier, "es2015", true)
    );
    const ignoreIdentifier = (identifier) => locals.delete(identifier);
    const getFreeIdentifier = (candidate, force = false) => {
      const suffix = "$";
      let counter = 0;
      if (isIdentifierFree(candidate) && !force) {
        addLocal(candidate);
        return candidate;
      }
      while (true) {
        const currentCandidate = candidate + suffix + String(counter);
        if (!isIdentifierFree(currentCandidate)) {
          counter++;
        } else {
          addLocal(currentCandidate);
          return currentCandidate;
        }
      }
    };
    return {
      ...context,
      transformSourceFile,
      exportsName: void 0,
      addImport,
      addLocal,
      markLocalAsExported,
      markDefaultAsExported,
      isLocalExported,
      isModuleSpecifierImportedWithoutLocals,
      getImportDeclarationWithModuleSpecifier,
      getLocalForDefaultImportFromModule,
      hasLocalForDefaultImportFromModule,
      getLocalForNamespaceImportFromModule,
      hasLocalForNamespaceImportFromModule,
      getLocalForNamedImportPropertyNameFromModule,
      hasLocalForNamedImportPropertyNameFromModule,
      addLeadingStatements,
      addTrailingStatements,
      isIdentifierFree,
      getFreeIdentifier,
      ignoreIdentifier,
      getModuleExportsForPath: (p) => moduleExportsMap.get(path5.normalize(p)),
      addModuleExportsForPath: (p, exports) => moduleExportsMap.set(path5.normalize(p), exports),
      get imports() {
        return [...imports.entries()].filter(([, { noEmit }]) => !noEmit).map(([declaration]) => declaration);
      },
      get leadingStatements() {
        return leadingStatements;
      },
      get trailingStatements() {
        return trailingStatements;
      },
      get isDefaultExported() {
        return isDefaultExported;
      },
      get exportedLocals() {
        return exportedLocals;
      }
    };
  })();
  const visitorBaseOptions = {
    context: visitorContext,
    continuation: (node) => visitNode({
      ...visitorBaseOptions,
      sourceFile,
      node
    }),
    childContinuation: (node) => typescript.visitEachChild(
      node,
      (cbNode) => {
        const visitResult = visitNode({
          ...visitorBaseOptions,
          sourceFile,
          node: cbNode
        });
        if (shouldSkipEmit(visitResult, typescript)) {
          return factory.createNotEmittedStatement(cbNode);
        }
        return visitResult;
      },
      transformationContext
    )
  };
  const importVisitorBaseOptions = {
    context: visitorContext,
    continuation: (node) => visitImportAndExportDeclarations({
      ...importVisitorBaseOptions,
      sourceFile,
      node
    }),
    childContinuation: (node) => typescript.visitEachChild(
      node,
      (cbNode) => {
        const visitResult = visitImportAndExportDeclarations({
          ...importVisitorBaseOptions,
          sourceFile,
          node: cbNode
        });
        if (shouldSkipEmit(visitResult, typescript)) {
          return factory.createNotEmittedStatement(cbNode);
        }
        return visitResult;
      },
      transformationContext
    )
  };
  visitImportAndExportDeclarations({ ...importVisitorBaseOptions, sourceFile, node: sourceFile });
  let updatedSourceFile = visitNode({ ...visitorBaseOptions, sourceFile, node: sourceFile });
  const allImports = [
    ...visitorContext.imports,
    ...visitorContext.leadingStatements.filter(typescript.isImportDeclaration),
    ...updatedSourceFile.statements.filter(typescript.isImportDeclaration),
    ...visitorContext.trailingStatements.filter(typescript.isImportDeclaration)
  ];
  const allExports = [
    ...visitorContext.leadingStatements.filter((statement) => typescript.isExportDeclaration(statement) || typescript.isExportAssignment(statement)),
    ...updatedSourceFile.statements.filter((statement) => typescript.isExportDeclaration(statement) || typescript.isExportAssignment(statement)),
    ...visitorContext.trailingStatements.filter((statement) => typescript.isExportDeclaration(statement) || typescript.isExportAssignment(statement))
  ];
  const allOtherStatements = [
    ...visitorContext.leadingStatements.filter((statement) => !allImports.includes(statement) && !allExports.includes(statement)),
    ...updatedSourceFile.statements.filter(
      (statement) => !allImports.includes(statement) && !allExports.includes(statement) && statement.kind !== typescript.SyntaxKind.NotEmittedStatement
    ),
    ...visitorContext.trailingStatements.filter((statement) => !allImports.includes(statement) && !allExports.includes(statement))
  ];
  updatedSourceFile = factory.updateSourceFile(
    updatedSourceFile,
    [...allImports, ...allOtherStatements, ...allExports],
    sourceFile.isDeclarationFile,
    sourceFile.referencedFiles,
    sourceFile.typeReferenceDirectives,
    sourceFile.hasNoDefaultLib,
    sourceFile.libReferenceDirectives
  );
  const moduleExports = {
    hasDefaultExport: false,
    namedExports: /* @__PURE__ */ new Set()
  };
  for (const statement of updatedSourceFile.statements) {
    if (typescript.isExportDeclaration(statement) && statement.exportClause != null && typescript.isNamedExports(statement.exportClause)) {
      for (const element of statement.exportClause.elements) {
        moduleExports.namedExports.add(element.name.text);
      }
    } else if (typescript.isExportAssignment(statement)) {
      moduleExports.hasDefaultExport = true;
    } else if (hasExportModifier(statement, typescript)) {
      if (hasDefaultExportModifier(statement, typescript)) {
        moduleExports.hasDefaultExport = true;
      } else if (typescript.isVariableStatement(statement)) {
        for (const declaration of statement.declarationList.declarations) {
          for (const local of getLocalsForBindingName(declaration.name, typescript)) {
            moduleExports.namedExports.add(local);
          }
        }
      } else if (isNamedDeclaration(statement, typescript) && statement.name != null && typescript.isIdentifier(statement.name)) {
        moduleExports.namedExports.add(statement.name.text);
      }
    }
  }
  visitorContext.addModuleExportsForPath(path5.normalize(sourceFile.fileName), moduleExports);
  if (!visitorContext.onlyExports && shouldDebug(visitorContext.debug, sourceFile) && visitorContext.printer != null) {
    visitorContext.logger.debug("===", path5.native.normalize(sourceFile.fileName), "===");
    visitorContext.logger.debug(visitorContext.printer.printFile(updatedSourceFile));
    visitorContext.logger.debug("EXPORTS:", visitorContext.exportedLocals);
  }
  return {
    sourceFile: updatedSourceFile,
    exports: moduleExports
  };
}

// src/shared/file-system/file-system.ts
import fs from "fs";
var realReadonlyFileSystem = {
  statSync: fs.statSync,
  lstatSync: fs.lstatSync,
  readdirSync: fs.readdirSync,
  readFileSync: fs.readFileSync
};
var realFileSystem = {
  ...realReadonlyFileSystem,
  mkdirSync: fs.mkdirSync,
  writeFileSync: fs.writeFileSync
};
function createSafeFileSystem(fileSystem) {
  return {
    ...fileSystem,
    safeReadFileSync: (path9) => {
      try {
        return fileSystem.readFileSync(path9);
      } catch {
        return void 0;
      }
    },
    safeStatSync: (path9) => {
      try {
        return fileSystem.statSync(path9);
      } catch {
        return void 0;
      }
    }
  };
}

// src/shared/logger/logger.ts
import color from "ansi-colors";
var Logger = class {
  constructor(logLevel) {
    this.logLevel = logLevel;
  }
  VERBOSE_COLOR = "cyan";
  WARNING_COLOR = "yellow";
  DEBUG_COLOR = "magenta";
  /**
   * Logs info-related messages
   */
  info(...messages) {
    if (this.logLevel < 1 /* INFO */) return;
    console.log(...messages);
  }
  /**
   * Logs verbose-related messages
   */
  verbose(...messages) {
    if (this.logLevel < 2 /* VERBOSE */) return;
    console.log(color[this.VERBOSE_COLOR]("[VERBOSE]"), ...messages);
  }
  /**
   * Logs debug-related messages
   */
  debug(...messages) {
    if (this.logLevel < 3 /* DEBUG */) return;
    console.log(color[this.DEBUG_COLOR]("[DEBUG]"), ...messages);
  }
  /**
   * Logs warning-related messages
   */
  warn(...messages) {
    console.log(color[this.WARNING_COLOR](`(!)`), ...messages);
  }
};

// src/shared/task/create-task-options.ts
import ts from "typescript";
function createTaskOptions({
  typescript = ts,
  fileSystem = realReadonlyFileSystem,
  debug = false,
  cwd = process.cwd(),
  preserveModuleSpecifiers = "external",
  importAttributes = true,
  logger = new Logger(debug !== false ? 3 /* DEBUG */ : 0 /* NONE */)
} = {}) {
  return {
    typescript,
    fileSystem,
    debug,
    cwd,
    preserveModuleSpecifiers,
    importAttributes,
    logger
  };
}

// src/transformer/cjs-to-esm-transformer.ts
import { ensureNodeFactory } from "compatfactory";
function cjsToEsmTransformer(options = {}) {
  return (context) => {
    const sanitizedOptions = createTaskOptions(options);
    const { fileSystem, typescript } = sanitizedOptions;
    const visitorContext = {
      ...sanitizedOptions,
      transformationContext: context,
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      factory: ensureNodeFactory(context.factory ?? typescript),
      fileSystem: createSafeFileSystem(fileSystem),
      onlyExports: false,
      resolveCache: /* @__PURE__ */ new Map(),
      printer: typescript.createPrinter()
    };
    return (sourceFile) => {
      return transformSourceFile(sourceFile, visitorContext).sourceFile;
    };
  };
}

// src/transformer/cjs-to-esm.ts
function cjsToEsm(options) {
  return {
    before: [cjsToEsmTransformer(options)]
  };
}

// src/cli/task/transform/transform-task.ts
import { inspect } from "util";
import fastGlob from "fast-glob";

// src/shared/compiler-host/create-compiler-host.ts
import path6 from "crosspath";
function createCompilerHost({ cwd, fileSystem, typescript }) {
  return {
    readFile(fileName) {
      try {
        return fileSystem.readFileSync(fileName).toString();
      } catch {
        return void 0;
      }
    },
    directoryExists(directoryName) {
      try {
        return fileSystem.statSync(directoryName).isDirectory();
      } catch {
        return false;
      }
    },
    fileExists(directoryName) {
      try {
        return fileSystem.statSync(directoryName).isFile();
      } catch {
        return false;
      }
    },
    writeFile: () => {
    },
    getSourceFile(fileName, languageVersion) {
      const normalized = path6.normalize(fileName);
      const sourceText = this.readFile(fileName);
      if (sourceText == null) return void 0;
      return typescript.createSourceFile(normalized, sourceText, languageVersion, true, getScriptKindFromPath(normalized, typescript));
    },
    getCurrentDirectory() {
      return path6.native.normalize(cwd);
    },
    getDirectories(directoryName) {
      return typescript.sys.getDirectories(directoryName).map(path6.native.normalize);
    },
    getDefaultLibFileName(compilerOpts) {
      return typescript.getDefaultLibFileName(compilerOpts);
    },
    getCanonicalFileName(fileName) {
      return this.useCaseSensitiveFileNames() ? fileName : fileName.toLowerCase();
    },
    getNewLine() {
      return typescript.sys.newLine;
    },
    useCaseSensitiveFileNames() {
      return typescript.sys.useCaseSensitiveFileNames;
    },
    realpath(p) {
      return path6.native.normalize(p);
    }
  };
}
var getScriptKindFromPath = (p, typescript) => {
  if (p.endsWith(".js")) {
    return typescript.ScriptKind.JS;
  } else if (p.endsWith(".ts") || p.endsWith(".mts") || p.endsWith(".cts")) {
    return typescript.ScriptKind.TS;
  } else if (p.endsWith(".tsx")) {
    return typescript.ScriptKind.TSX;
  } else if (p.endsWith(".jsx")) {
    return typescript.ScriptKind.JSX;
  } else if (p.endsWith(".json")) {
    return typescript.ScriptKind.JSON;
  } else {
    return typescript.ScriptKind.Unknown;
  }
};

// src/cli/task/transform/transform-task.ts
import color2 from "ansi-colors";
import path7 from "crosspath";

// src/shared/constant.ts
var TEMPORARY_SUBFOLDER_NAME = "__$$temporary_subfolder$$__";

// src/cli/task/transform/transform-task.ts
async function transformTask(options) {
  let { logger, input, cwd, outDir, fileSystem, write, typescript, debug, preserveModuleSpecifiers, importAttributes, hooks } = options;
  logger.debug(
    "Options:",
    inspect(
      { input, outDir, cwd, write, debug, preserveModuleSpecifiers, importAttributes },
      {
        colors: true,
        depth: Infinity,
        maxArrayLength: Infinity
      }
    )
  );
  const matchedFiles = new Set(
    ensureArray(input).flatMap(
      (glob) => fastGlob.sync(normalizeGlob(path7.normalize(glob)), { fs: fileSystem }).map((file) => path7.isAbsolute(file) ? path7.normalize(file) : path7.join(cwd, file))
    )
  );
  logger.debug(`Matched files:`, matchedFiles.size < 1 ? "(none)" : [...matchedFiles].map((f) => `"${path7.native.normalize(f)}"`).join(", "));
  const result = {
    files: []
  };
  if (matchedFiles.size < 1) {
    return result;
  }
  const closestFolderToRoot = getFolderClosestToRoot(cwd, matchedFiles);
  if (outDir == null) {
    outDir = path7.join(closestFolderToRoot, TEMPORARY_SUBFOLDER_NAME);
  }
  const compilerOptions = {
    target: typescript.ScriptTarget.ESNext,
    allowJs: true,
    declaration: false,
    outDir,
    sourceMap: false,
    newLine: typescript.sys.newLine === "\n" ? typescript.NewLineKind.LineFeed : typescript.NewLineKind.CarriageReturnLineFeed,
    rootDir: closestFolderToRoot,
    module: typescript.ModuleKind.ESNext,
    // eslint-disable-next-line @typescript-eslint/no-deprecated, @typescript-eslint/naming-convention
    moduleResolution: typescript.ModuleResolutionKind.Bundler ?? typescript.ModuleResolutionKind.NodeJs
  };
  const program = typescript.createProgram({
    rootNames: [...matchedFiles],
    options: compilerOptions,
    host: createCompilerHost({
      cwd,
      fileSystem,
      typescript
    })
  });
  program.emit(
    void 0,
    (fileName, text) => {
      const newFilename = path7.normalize(fileName).replace(`/${TEMPORARY_SUBFOLDER_NAME}`, ``);
      const nativeNormalizedFileName = path7.native.normalize(newFilename);
      if (hooks.writeFile != null) {
        const hookResult = hooks.writeFile(nativeNormalizedFileName, text);
        if (hookResult != null) {
          text = hookResult;
        }
      }
      result.files.push({ fileName: nativeNormalizedFileName, text });
      if (write) {
        fileSystem.mkdirSync(path7.native.dirname(nativeNormalizedFileName), { recursive: true });
        fileSystem.writeFileSync(nativeNormalizedFileName, text);
      }
      logger.info(`${color2.green("\u2714")} ${path7.native.relative(cwd, nativeNormalizedFileName)}`);
    },
    void 0,
    false,
    cjsToEsm(options)
  );
  return result;
}

// src/shared/task/create-transform-task-options.ts
import path8 from "crosspath";
function createTransformTaskOptions({
  fileSystem = realFileSystem,
  write = true,
  input,
  hooks = {},
  outDir,
  ...rest
}) {
  if (input == null) {
    throw new ReferenceError(`Missing required argument: 'input'`);
  }
  const taskOptions = createTaskOptions(rest);
  return {
    ...taskOptions,
    write,
    fileSystem,
    hooks,
    input: ensureArray(input).map((file) => path8.normalize(path8.isAbsolute(file) ? file : path8.join(taskOptions.cwd, file))),
    outDir: outDir == null ? void 0 : path8.normalize(path8.isAbsolute(outDir) ? outDir : path8.join(taskOptions.cwd, outDir))
  };
}

export {
  Logger,
  cjsToEsmTransformer,
  cjsToEsm,
  transformTask,
  createTransformTaskOptions
};
//# sourceMappingURL=chunk-NOCWFHS7.js.map