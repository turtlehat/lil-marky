"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ensureNodeFactory: () => ensureNodeFactory
});
module.exports = __toCommonJS(src_exports);
function ensureNodeFactory(factoryLike) {
  if ("factory" in factoryLike && factoryLike.factory != null) {
    return normalizeNodeFactory(factoryLike.factory);
  } else if (!("updateSourceFileNode" in factoryLike)) {
    return normalizeNodeFactory(factoryLike);
  }
  return createNodeFactory(factoryLike);
}
function splitDecoratorsAndModifiers(modifierLikes) {
  const decorators = modifierLikes?.filter((modifier) => "expression" in modifier) ?? [];
  const modifiers = modifierLikes?.filter((modifier) => !("expression" in modifier)) ?? [];
  return [decorators == null || decorators.length < 1 ? void 0 : decorators, modifiers == null || modifiers.length < 1 ? void 0 : modifiers];
}
function normalizeNodeFactory(factory) {
  const ts4CastFactory = factory;
  if (Boolean(factory.__compatUpgraded)) {
    return factory;
  }
  let badDecoratorsAsFirstArgument = false;
  try {
    badDecoratorsAsFirstArgument = ts4CastFactory.createImportEqualsDeclaration([], false, "", ts4CastFactory.createIdentifier("")).decorators != null;
  } catch {
    badDecoratorsAsFirstArgument = ts4CastFactory.createImportEqualsDeclaration([], [], false, "", ts4CastFactory.createIdentifier("")).decorators != null;
  }
  const badCreateImportEqualsDeclaration = badDecoratorsAsFirstArgument && factory.createImportEqualsDeclaration.length === 4;
  const badCreateImportSpecifier = badDecoratorsAsFirstArgument && factory.createImportSpecifier.length === 2;
  const badCreateExportSpecifier = badDecoratorsAsFirstArgument && factory.createExportSpecifier.length === 2;
  const badCreateMappedTypeNodeA = badDecoratorsAsFirstArgument && factory.createMappedTypeNode.length === 4;
  const badCreateMappedTypeNodeB = badDecoratorsAsFirstArgument && factory.createMappedTypeNode.length === 5;
  const badCreateTypeParameterDeclaration = badDecoratorsAsFirstArgument && factory.createTypeParameterDeclaration.length === 3;
  const badCreateImportTypeNode = factory.createImportAttribute == null;
  const badCreateImportDeclaration = !badDecoratorsAsFirstArgument && factory.createImportAttribute == null;
  const badCreateExportDeclaration = !badDecoratorsAsFirstArgument && factory.createImportAttribute == null;
  const missingCreateSatisfiesExpression = factory.createSatisfiesExpression == null;
  const missingCreateClassStaticBlockDeclaration = factory.createClassStaticBlockDeclaration == null;
  const missingCreateUniquePrivateName = factory.createUniquePrivateName == null;
  const missingGetGeneratedPrivateNameForNode = factory.getGeneratedPrivateNameForNode == null;
  const missingCreatePrivateIdentifier = factory.createPrivateIdentifier == null;
  const missingCreateAssertClause = factory.createAssertClause == null;
  const missingCreateAssertEntry = factory.createAssertEntry == null;
  const missingCreateImportTypeAssertionContainer = factory.createImportTypeAssertionContainer == null;
  const missingCreateImportAttributes = factory.createImportAttributes == null;
  const missingCreateImportAttribute = factory.createImportAttribute == null;
  const missingCreateJSDocMemberName = factory.createJSDocMemberName == null;
  const missingCreateJSDocLinkCode = factory.createJSDocLinkCode == null;
  const missingCreateJSDocLinkPlain = factory.createJSDocLinkPlain == null;
  const missingCreateJSDocOverloadTag = factory.createJSDocOverloadTag == null;
  const missingCreateJSDocThrowsTag = factory.createJSDocThrowsTag == null;
  const missingCreateJSDocSatisfiesTag = factory.createJSDocSatisfiesTag == null;
  const missingCreateJSDocImportTag = factory.createJSDocImportTag == null;
  const missingCreateJsxNamespacedName = factory.createJsxNamespacedName == null;
  const missingReplaceModifiers = factory.replaceModifiers == null;
  const missingReplaceDecoratorsAndModifiers = factory.replaceDecoratorsAndModifiers == null;
  const missingReplacePropertyName = factory.replacePropertyName == null;
  const needsModifications = badCreateImportEqualsDeclaration || badCreateImportSpecifier || badCreateExportSpecifier || badCreateImportTypeNode || badCreateImportDeclaration || badCreateExportDeclaration || badCreateMappedTypeNodeA || badCreateMappedTypeNodeB || badCreateTypeParameterDeclaration || missingCreateSatisfiesExpression || missingCreateClassStaticBlockDeclaration || missingCreateUniquePrivateName || missingGetGeneratedPrivateNameForNode || missingCreatePrivateIdentifier || missingCreateAssertClause || missingCreateAssertEntry || missingCreateImportTypeAssertionContainer || missingCreateImportAttributes || missingCreateImportAttribute || missingCreateJSDocMemberName || missingCreateJSDocLinkCode || missingCreateJSDocLinkPlain || missingCreateJSDocOverloadTag || missingCreateJSDocThrowsTag || missingCreateJSDocSatisfiesTag || missingCreateJSDocImportTag || missingCreateJsxNamespacedName || missingReplaceModifiers || missingReplaceDecoratorsAndModifiers || missingReplacePropertyName || badDecoratorsAsFirstArgument;
  if (needsModifications) {
    const withOriginal = "original" in factory.updateBlock(factory.createBlock([]), []);
    const setOriginalNode = (node, original) => {
      node.original = original;
      return node;
    };
    const setTextRangeEnd = (range, end) => {
      range.end = end;
      return range;
    };
    const setTextRangePos = (range, pos) => {
      range.pos = pos;
      return range;
    };
    const setTextRangePosEnd = (range, pos, end) => setTextRangeEnd(setTextRangePos(range, pos), end);
    const setTextRange = (range, loc) => loc != null ? setTextRangePosEnd(range, loc.pos, loc.end) : range;
    const updateWithoutOriginal = (updated, original) => {
      if (updated !== original) {
        setTextRange(updated, original);
      }
      return updated;
    };
    const updateWithOriginal = (updated, original) => {
      if (updated !== original) {
        setOriginalNode(updated, original);
        setTextRange(updated, original);
      }
      return updated;
    };
    const update = withOriginal ? updateWithOriginal : updateWithoutOriginal;
    const createPrivateIdentifier = missingCreatePrivateIdentifier ? /* @__PURE__ */ (() => function(text) {
      const node = factory.createIdentifier(text);
      return node;
    })() : factory.createPrivateIdentifier;
    return {
      ["__compatUpgraded"]: true,
      ...factory,
      createPrivateIdentifier,
      ...badCreateImportEqualsDeclaration ? /* @__PURE__ */ (() => {
        function createImportEqualsDeclaration(decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
          const isShort = arguments.length <= 4;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
          const name = isShort ? isTypeOnlyOrName : nameOrModuleReference;
          const moduleReference = isShort ? nameOrModuleReference : moduleReferenceOrUndefined;
          return factory.createImportEqualsDeclaration(
            decorators,
            modifiers,
            name,
            moduleReference
          );
        }
        function updateImportEqualsDeclaration(node, decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
          const isShort = arguments.length <= 5;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
          const name = isShort ? isTypeOnlyOrName : nameOrModuleReference;
          const moduleReference = isShort ? nameOrModuleReference : moduleReferenceOrUndefined;
          return factory.updateImportEqualsDeclaration(
            node,
            decorators,
            modifiers,
            name,
            moduleReference
          );
        }
        return {
          createImportEqualsDeclaration,
          updateImportEqualsDeclaration
        };
      })() : {},
      ...badCreateImportSpecifier ? {
        createImportSpecifier(isTypeOnly, propertyName, name) {
          return factory.createImportSpecifier(propertyName, name);
        },
        updateImportSpecifier(node, isTypeOnly, propertyName, name) {
          return factory.updateImportSpecifier(
            node,
            propertyName,
            name
          );
        }
      } : {},
      ...badCreateExportSpecifier ? {
        createExportSpecifier(isTypeOnly, propertyName, name) {
          return factory.createExportSpecifier(propertyName, name);
        },
        updateExportSpecifier(node, isTypeOnly, propertyName, name) {
          return factory.updateExportSpecifier(
            node,
            propertyName,
            name
          );
        }
      } : {},
      ...badCreateImportTypeNode ? /* @__PURE__ */ (() => {
        function createImportTypeNode(argument, attributesOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined) {
          const qualifier = attributesOrQualifier != null && attributesOrQualifier.kind === 300 ? void 0 : attributesOrQualifier;
          if (arguments.length < 5) {
            return factory.createImportTypeNode(
              argument,
              qualifier,
              qualifierOrTypeArguments,
              typeArgumentsOrIsTypeOf
            );
          } else {
            return factory.createImportTypeNode(
              argument,
              qualifierOrTypeArguments,
              typeArgumentsOrIsTypeOf,
              isTypeOfOrUndefined
            );
          }
        }
        function updateImportTypeNode(node, argument, attributesOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined) {
          const qualifierOrUndefined = attributesOrQualifier != null && attributesOrQualifier.kind === 300 ? void 0 : attributesOrQualifier;
          if (arguments.length < 6) {
            return factory.updateImportTypeNode(
              node,
              argument,
              qualifierOrUndefined,
              qualifierOrTypeArguments,
              typeArgumentsOrIsTypeOf
            );
          } else {
            return factory.updateImportTypeNode(
              node,
              argument,
              qualifierOrTypeArguments,
              typeArgumentsOrIsTypeOf,
              isTypeOfOrUndefined
            );
          }
        }
        return { createImportTypeNode, updateImportTypeNode };
      })() : {},
      ...badCreateImportDeclaration ? /* @__PURE__ */ (() => {
        function createImportDeclaration(modifiers, importClause, moduleSpecifier, _) {
          return factory.createImportDeclaration(
            modifiers,
            importClause,
            moduleSpecifier
          );
        }
        function updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, _) {
          return factory.updateImportDeclaration(
            node,
            modifiers,
            importClause,
            moduleSpecifier,
            void 0
          );
        }
        return { createImportDeclaration, updateImportDeclaration };
      })() : {},
      ...badCreateExportDeclaration ? /* @__PURE__ */ (() => {
        function createExportDeclaration(modifiers, isTypeOnly, exportClause, moduleSpecifier, _) {
          return factory.createExportDeclaration(
            modifiers,
            isTypeOnly,
            exportClause,
            moduleSpecifier
          );
        }
        function updateExportDeclaration(node, modifiers, isTypeOnly, exportClause, moduleSpecifier, _) {
          return factory.updateExportDeclaration(
            node,
            modifiers,
            isTypeOnly,
            exportClause,
            moduleSpecifier,
            void 0
          );
        }
        return { createExportDeclaration, updateExportDeclaration };
      })() : {},
      ...badCreateMappedTypeNodeA ? {
        createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type) {
          return factory.createMappedTypeNode(
            readonlyToken,
            typeParameter,
            questionToken,
            type
          );
        },
        updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type) {
          return factory.updateMappedTypeNode(
            node,
            readonlyToken,
            typeParameter,
            questionToken,
            type
          );
        }
      } : {},
      ...badCreateMappedTypeNodeB ? {
        createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members) {
          return factory.createMappedTypeNode(
            readonlyToken,
            typeParameter,
            nameType,
            questionToken,
            type
          );
        },
        updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type, members) {
          return factory.updateMappedTypeNode(
            node,
            readonlyToken,
            typeParameter,
            nameType,
            questionToken,
            type
          );
        }
      } : {},
      ...badCreateTypeParameterDeclaration ? /* @__PURE__ */ (() => {
        function createTypeParameterDeclaration(modifiersOrName, nameOrConstraint, constraintOrDefaultType, defaultTypeOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
          const modifiers = isShort ? void 0 : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrConstraint;
          const constraint = isShort ? nameOrConstraint : constraintOrDefaultType;
          const defaultType = isShort ? constraintOrDefaultType : defaultTypeOrUndefined;
          const typeParameterDeclaration = factory.createTypeParameterDeclaration(
            name,
            constraint,
            defaultType
          );
          if (modifiers != null) {
            typeParameterDeclaration.modifiers = factory.createNodeArray(modifiers);
          }
          return typeParameterDeclaration;
        }
        function updateTypeParameterDeclaration(node, modifiersOrName, nameOrConstraint, constraintOrDefaultType, defaultTypeOrUndefined) {
          const isShort = modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
          const modifiers = isShort ? void 0 : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrConstraint;
          const constraint = isShort ? nameOrConstraint : constraintOrDefaultType;
          const defaultType = isShort ? constraintOrDefaultType : defaultTypeOrUndefined;
          const typeParameterDeclaration = factory.updateTypeParameterDeclaration(
            node,
            name,
            constraint,
            defaultType
          );
          if (modifiers != null) {
            typeParameterDeclaration.modifiers = factory.createNodeArray(modifiers);
          }
          return typeParameterDeclaration;
        }
        return {
          createTypeParameterDeclaration,
          updateTypeParameterDeclaration
        };
      })() : {},
      ...missingCreateSatisfiesExpression ? /* @__PURE__ */ (() => {
        function createSatisfiesExpression(expression, type) {
          return { ...expression };
        }
        function updateSatisfiesExpression(node, expression, type) {
          return expression === node.expression && type === node.type ? node : update(createSatisfiesExpression(expression, type), node);
        }
        return {
          createSatisfiesExpression,
          updateSatisfiesExpression
        };
      })() : {},
      ...missingCreateUniquePrivateName ? /* @__PURE__ */ (() => {
        function createUniquePrivateName(text) {
          if (text != null && !text.startsWith("#")) {
            throw new TypeError("First character of private identifier must be #: " + text);
          }
          const node = createPrivateIdentifier(text ?? "");
          return node;
        }
        return {
          createUniquePrivateName
        };
      })() : {},
      ...missingGetGeneratedPrivateNameForNode ? /* @__PURE__ */ (() => {
        function getGeneratedPrivateNameForNode(node) {
          return createPrivateIdentifier("");
        }
        return {
          getGeneratedPrivateNameForNode
        };
      })() : {},
      ...missingCreateClassStaticBlockDeclaration ? /* @__PURE__ */ (() => {
        function createClassStaticBlockDeclaration(decoratorsOrBlock, modifiersOrUndefined, bodyOrUndefined) {
          const body = arguments.length >= 3 ? bodyOrUndefined : decoratorsOrBlock;
          const node = factory.createEmptyStatement();
          node.body = body;
          node.transformFlags = 8388608;
          return node;
        }
        function updateClassStaticBlockDeclaration(node, decoratorsOrBlock, modifiersOrUndefined, bodyOrUndefined) {
          const body = arguments.length >= 4 ? bodyOrUndefined : decoratorsOrBlock;
          return body === node.body ? node : update(createClassStaticBlockDeclaration(body), node);
        }
        return {
          createClassStaticBlockDeclaration,
          updateClassStaticBlockDeclaration
        };
      })() : {},
      ...missingCreateAssertClause ? /* @__PURE__ */ (() => {
        function createAssertClause(elements, multiLine) {
          const node = factory.createEmptyStatement();
          node.elements = elements;
          node.multiLine = multiLine;
          node.transformFlags |= 4;
          return node;
        }
        function updateAssertClause(node, elements, multiLine) {
          return node.elements !== elements || node.multiLine !== multiLine ? update(createAssertClause(elements, multiLine), node) : node;
        }
        return {
          createAssertClause,
          updateAssertClause
        };
      })() : {},
      ...missingCreateAssertEntry ? /* @__PURE__ */ (() => {
        function createAssertEntry(name, value) {
          const node = factory.createEmptyStatement();
          node.name = name;
          node.value = value;
          node.transformFlags |= 4;
          return node;
        }
        function updateAssertEntry(node, name, value) {
          return node.name !== name || node.value !== value ? update(createAssertEntry(name, value), node) : node;
        }
        return {
          createAssertEntry,
          updateAssertEntry
        };
      })() : {},
      ...missingCreateImportTypeAssertionContainer ? /* @__PURE__ */ (() => {
        function createImportTypeAssertionContainer(clause, multiLine) {
          const node = factory.createEmptyStatement();
          node.assertClause = clause;
          node.multiLine = multiLine;
          return node;
        }
        function updateImportTypeAssertionContainer(node, clause, multiLine) {
          return node.assertClause !== clause || node.multiLine !== multiLine ? update(createImportTypeAssertionContainer(clause, multiLine), node) : node;
        }
        return {
          createImportTypeAssertionContainer,
          updateImportTypeAssertionContainer
        };
      })() : {},
      ...missingCreateImportAttributes ? /* @__PURE__ */ (() => {
        function createImportAttributes(elements, multiLine) {
          const node = factory.createEmptyStatement();
          node.elements = elements;
          node.multiLine = multiLine;
          return node;
        }
        function updateImportAttributes(node, elements, multiLine) {
          return node.elements !== elements || node.multiLine !== multiLine ? update(createImportAttributes(elements, multiLine), node) : node;
        }
        return {
          createImportAttributes,
          updateImportAttributes
        };
      })() : {},
      ...missingCreateImportAttribute ? /* @__PURE__ */ (() => {
        function createImportAttribute(name, value) {
          const node = factory.createEmptyStatement();
          node.name = name;
          node.value = value;
          return node;
        }
        function updateImportAttribute(node, name, value) {
          return node.name !== name || node.value !== value ? update(createImportAttribute(name, value), node) : node;
        }
        return {
          createImportAttribute,
          updateImportAttribute
        };
      })() : {},
      ...missingReplaceModifiers ? /* @__PURE__ */ (() => {
        function replaceModifiers(n, modifiers) {
          let modifierArray;
          if (typeof modifiers === "number") {
            modifierArray = factory.createModifiersFromModifierFlags(modifiers);
          } else {
            modifierArray = modifiers;
          }
          const clone = "cloneNode" in factory ? factory.cloneNode(n) : { ...n };
          clone.modifiers = factory.createNodeArray(modifierArray);
          return clone;
        }
        return {
          replaceModifiers
        };
      })() : {},
      ...missingReplaceDecoratorsAndModifiers ? /* @__PURE__ */ (() => {
        function replaceDecoratorsAndModifiers(n, modifiers) {
          const clone = "cloneNode" in factory ? factory.cloneNode(n) : { ...n };
          clone.modifiers = factory.createNodeArray(modifiers);
          return clone;
        }
        return {
          replaceDecoratorsAndModifiers
        };
      })() : {},
      ...missingReplacePropertyName ? /* @__PURE__ */ (() => {
        function replacePropertyName(n, name) {
          const clone = "cloneNode" in factory ? factory.cloneNode(n) : { ...n };
          clone.name = name;
          return clone;
        }
        return {
          replacePropertyName
        };
      })() : {},
      ...missingCreateJSDocMemberName ? /* @__PURE__ */ (() => {
        function createJSDocMemberName(left, right) {
          const base = factory.createJSDocComment(void 0, void 0);
          delete base.comment;
          delete base.tags;
          const node = base;
          node.left = left;
          node.right = right;
          return node;
        }
        function updateJSDocMemberName(node, left, right) {
          return left === node.left && right === node.right ? node : update(createJSDocMemberName(left, right), node);
        }
        return {
          createJSDocMemberName,
          updateJSDocMemberName
        };
      })() : {},
      ...missingCreateJSDocLinkCode ? /* @__PURE__ */ (() => {
        function createJSDocLinkCode(name, text) {
          const base = factory.createJSDocComment(void 0, void 0);
          delete base.comment;
          delete base.tags;
          const node = base;
          node.name = name;
          node.text = text;
          return node;
        }
        function updateJSDocLinkCode(node, name, text) {
          return name === node.name && text === node.text ? node : update(createJSDocLinkCode(name, text), node);
        }
        return {
          createJSDocLinkCode,
          updateJSDocLinkCode
        };
      })() : {},
      ...missingCreateJSDocLinkPlain ? /* @__PURE__ */ (() => {
        function createJSDocLinkPlain(name, text) {
          const base = factory.createJSDocComment(void 0, void 0);
          delete base.comment;
          delete base.tags;
          const node = base;
          node.name = name;
          node.text = text;
          return node;
        }
        function updateJSDocLinkPlain(node, name, text) {
          return name === node.name && text === node.text ? node : update(createJSDocLinkPlain(name, text), node);
        }
        return {
          createJSDocLinkPlain,
          updateJSDocLinkPlain
        };
      })() : {},
      ...missingCreateJSDocOverloadTag ? /* @__PURE__ */ (() => {
        function createJSDocOverloadTag(tagName, typeExpression, comment) {
          const base = factory.createJSDocComment(void 0, void 0);
          delete base.comment;
          delete base.tags;
          const node = base;
          if (tagName != null) node.tagName = tagName;
          node.typeExpression = typeExpression;
          node.comment = comment;
          return node;
        }
        function updateJSDocOverloadTag(node, tagName, typeExpression, comment) {
          return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment ? node : update(createJSDocOverloadTag(tagName, typeExpression, comment), node);
        }
        return {
          createJSDocOverloadTag,
          updateJSDocOverloadTag
        };
      })() : {},
      ...missingCreateJSDocThrowsTag ? /* @__PURE__ */ (() => {
        function createJSDocThrowsTag(tagName, typeExpression, comment) {
          const base = factory.createJSDocComment(void 0, void 0);
          delete base.comment;
          delete base.tags;
          const node = base;
          if (tagName != null) node.tagName = tagName;
          node.typeExpression = typeExpression;
          node.comment = comment;
          return node;
        }
        function updateJSDocThrowsTag(node, tagName, typeExpression, comment) {
          return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment ? node : update(createJSDocThrowsTag(tagName ?? node.tagName, typeExpression, comment), node);
        }
        return {
          createJSDocThrowsTag,
          updateJSDocThrowsTag
        };
      })() : {},
      ...missingCreateJSDocSatisfiesTag ? /* @__PURE__ */ (() => {
        function createJSDocSatisfiesTag(tagName, typeExpression, comment) {
          const base = factory.createJSDocComment(void 0, void 0);
          delete base.comment;
          delete base.tags;
          const node = base;
          if (tagName != null) node.tagName = tagName;
          node.typeExpression = typeExpression;
          node.comment = comment;
          return node;
        }
        function updateJSDocSatisfiesTag(node, tagName, typeExpression, comment) {
          return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment ? node : update(createJSDocSatisfiesTag(tagName, typeExpression, comment), node);
        }
        return {
          createJSDocSatisfiesTag,
          updateJSDocSatisfiesTag
        };
      })() : {},
      ...missingCreateJSDocImportTag ? /* @__PURE__ */ (() => {
        function createJSDocImportTag(tagName, importClause, moduleSpecifier, attributes, comment) {
          const base = factory.createJSDocComment(void 0, void 0);
          delete base.comment;
          delete base.tags;
          const node = base;
          if (tagName != null) node.tagName = tagName;
          node.comment = comment;
          node.importClause = importClause;
          node.moduleSpecifier = moduleSpecifier;
          node.attributes = attributes;
          return node;
        }
        function updateJSDocImportTag(node, tagName, importClause, moduleSpecifier, attributes, comment) {
          return tagName === node.tagName && importClause === node.importClause && comment === node.comment && moduleSpecifier === node.moduleSpecifier && attributes === node.attributes ? node : update(createJSDocImportTag(tagName, importClause, moduleSpecifier, attributes, comment), node);
        }
        return {
          createJSDocImportTag,
          updateJSDocImportTag
        };
      })() : {},
      ...missingCreateJsxNamespacedName ? /* @__PURE__ */ (() => {
        function createJsxNamespacedName(namespace, name) {
          const node = factory.createEmptyStatement();
          node.namespace = namespace;
          node.name = name;
          return node;
        }
        function updateJsxNamespacedName(node, namespace, name) {
          return node.namespace !== namespace || node.name !== name ? update(createJsxNamespacedName(namespace, name), node) : node;
        }
        return {
          createJsxNamespacedName,
          updateJsxNamespacedName
        };
      })() : {},
      ...badDecoratorsAsFirstArgument ? /* @__PURE__ */ (() => {
        function createParameterDeclaration(decoratorsOrModifiers, modifiersOrDotDotDotToken, dotDotDotTokenOrName, nameOrQuestionToken, questionTokenOrType, typeOrInitializer, initializerOrUndefined) {
          const isShort = typeof dotDotDotTokenOrName === "string" || dotDotDotTokenOrName != null && dotDotDotTokenOrName.kind !== 25;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrDotDotDotToken;
          const dotDotDotToken = isShort ? modifiersOrDotDotDotToken : dotDotDotTokenOrName;
          const name = isShort ? dotDotDotTokenOrName : nameOrQuestionToken;
          const questionToken = isShort ? nameOrQuestionToken : questionTokenOrType;
          const type = isShort ? questionTokenOrType : typeOrInitializer;
          const initializer = isShort ? typeOrInitializer : initializerOrUndefined;
          return factory.createParameterDeclaration(
            decorators,
            modifiers,
            dotDotDotToken,
            name,
            questionToken,
            type,
            initializer
          );
        }
        function updateParameterDeclaration(node, decoratorsOrModifiers, modifiersOrDotDotDotToken, dotDotDotTokenOrName, nameOrQuestionToken, questionTokenOrType, typeOrInitializer, initializerOrUndefined) {
          const isShort = typeof dotDotDotTokenOrName === "string" || dotDotDotTokenOrName != null && dotDotDotTokenOrName.kind !== 25;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrDotDotDotToken;
          const dotDotDotToken = isShort ? modifiersOrDotDotDotToken : dotDotDotTokenOrName;
          const name = isShort ? dotDotDotTokenOrName : nameOrQuestionToken;
          const questionToken = isShort ? nameOrQuestionToken : questionTokenOrType;
          const type = isShort ? questionTokenOrType : typeOrInitializer;
          const initializer = isShort ? typeOrInitializer : initializerOrUndefined;
          return factory.updateParameterDeclaration(
            node,
            decorators,
            modifiers,
            dotDotDotToken,
            name,
            questionToken,
            type,
            initializer
          );
        }
        function createPropertyDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrQuestionOrExclamationToken, questionOrExclamationTokenOrType, typeOrInitializer, initializerOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrQuestionOrExclamationToken;
          const questionOrExclamationToken = isShort ? nameOrQuestionOrExclamationToken : questionOrExclamationTokenOrType;
          const type = isShort ? questionOrExclamationTokenOrType : typeOrInitializer;
          const initializer = isShort ? typeOrInitializer : initializerOrUndefined;
          return factory.createPropertyDeclaration(
            decorators,
            modifiers,
            name,
            questionOrExclamationToken,
            type,
            initializer
          );
        }
        function updatePropertyDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrQuestionOrExclamationToken, questionOrExclamationTokenOrType, typeOrInitializer, initializerOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrQuestionOrExclamationToken;
          const questionOrExclamationToken = isShort ? nameOrQuestionOrExclamationToken : questionOrExclamationTokenOrType;
          const type = isShort ? questionOrExclamationTokenOrType : typeOrInitializer;
          const initializer = isShort ? typeOrInitializer : initializerOrUndefined;
          return factory.updatePropertyDeclaration(
            node,
            decorators,
            modifiers,
            name,
            questionOrExclamationToken,
            type,
            initializer
          );
        }
        function createMethodDeclaration(decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrQuestionToken, questionTokenOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
          const isShort = typeof asteriskTokenOrName === "string" || asteriskTokenOrName != null && asteriskTokenOrName.kind !== 41;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
          const asteriskToken = isShort ? modifiersOrAsteriskToken : asteriskTokenOrName;
          const name = isShort ? asteriskTokenOrName : nameOrQuestionToken;
          const questionToken = isShort ? nameOrQuestionToken : questionTokenOrTypeParameters;
          const typeParameters = isShort ? questionTokenOrTypeParameters : typeParametersOrParameters;
          const parameters = isShort ? typeParametersOrParameters : parametersOrType;
          const type = isShort ? parametersOrType : typeOrBody;
          const body = isShort ? typeOrBody : bodyOrUndefined;
          return factory.createMethodDeclaration(
            decorators,
            modifiers,
            asteriskToken,
            name,
            questionToken,
            typeParameters,
            parameters,
            type,
            body
          );
        }
        function updateMethodDeclaration(node, decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrQuestionToken, questionTokenOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
          const isShort = typeof asteriskTokenOrName === "string" || asteriskTokenOrName != null && asteriskTokenOrName.kind !== 41;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
          const asteriskToken = isShort ? modifiersOrAsteriskToken : asteriskTokenOrName;
          const name = isShort ? asteriskTokenOrName : nameOrQuestionToken;
          const questionToken = isShort ? nameOrQuestionToken : questionTokenOrTypeParameters;
          const typeParameters = isShort ? questionTokenOrTypeParameters : typeParametersOrParameters;
          const parameters = isShort ? typeParametersOrParameters : parametersOrType;
          const type = isShort ? parametersOrType : typeOrBody;
          const body = isShort ? typeOrBody : bodyOrUndefined;
          return factory.updateMethodDeclaration(
            node,
            decorators,
            modifiers,
            asteriskToken,
            name,
            questionToken,
            typeParameters,
            parameters,
            type,
            body
          );
        }
        function createConstructorDeclaration(decoratorsOrModifiers, modifiersOrParameters, parametersOrBody, bodyOrUndefined) {
          const isShort = arguments.length <= 3;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
          const parameters = isShort ? modifiersOrParameters : parametersOrBody;
          const body = isShort ? parametersOrBody : bodyOrUndefined;
          return factory.createConstructorDeclaration(
            decorators,
            modifiers,
            parameters,
            body
          );
        }
        function updateConstructorDeclaration(node, decoratorsOrModifiers, modifiersOrParameters, parametersOrBody, bodyOrUndefined) {
          const isShort = arguments.length <= 4;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
          const parameters = isShort ? modifiersOrParameters : parametersOrBody;
          const body = isShort ? parametersOrBody : bodyOrUndefined;
          return factory.updateConstructorDeclaration(
            node,
            decorators,
            modifiers,
            parameters,
            body
          );
        }
        function createGetAccessorDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrParameters;
          const parameters = isShort ? nameOrParameters : parametersOrType;
          const type = isShort ? parametersOrType : typeOrBody;
          const body = isShort ? typeOrBody : bodyOrUndefined;
          return factory.createGetAccessorDeclaration(
            decorators,
            modifiers,
            name,
            parameters,
            type,
            body
          );
        }
        function updateGetAccessorDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrParameters;
          const parameters = isShort ? nameOrParameters : parametersOrType;
          const type = isShort ? parametersOrType : typeOrBody;
          const body = isShort ? typeOrBody : bodyOrUndefined;
          return factory.updateGetAccessorDeclaration(
            node,
            decorators,
            modifiers,
            name,
            parameters,
            type,
            body
          );
        }
        function createSetAccessorDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrBody, bodyOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrParameters;
          const parameters = isShort ? nameOrParameters : parametersOrBody;
          const body = isShort ? parametersOrBody : bodyOrUndefined;
          return factory.createSetAccessorDeclaration(
            decorators,
            modifiers,
            name,
            parameters,
            body
          );
        }
        function updateSetAccessorDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrBody, bodyOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrParameters;
          const parameters = isShort ? nameOrParameters : parametersOrBody;
          const body = isShort ? parametersOrBody : bodyOrUndefined;
          return factory.updateSetAccessorDeclaration(
            node,
            decorators,
            modifiers,
            name,
            parameters,
            body
          );
        }
        function createIndexSignature(decoratorsOrModifiers, modifiersOrParameters, parametersOrType, typeOrUndefined) {
          const isShort = arguments.length <= 3;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
          const parameters = isShort ? modifiersOrParameters : parametersOrType;
          const type = isShort ? parametersOrType : typeOrUndefined;
          return factory.createIndexSignature(
            decorators,
            modifiers,
            parameters,
            type
          );
        }
        function updateIndexSignature(node, decoratorsOrModifiers, modifiersOrParameters, parametersOrType, typeOrUndefined) {
          const isShort = arguments.length <= 4;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
          const parameters = isShort ? modifiersOrParameters : parametersOrType;
          const type = isShort ? parametersOrType : typeOrUndefined;
          return factory.updateIndexSignature(
            node,
            decorators,
            modifiers,
            parameters,
            type
          );
        }
        function createClassStaticBlockDeclaration(decoratorsOrBody, modifiersOrUndefined, bodyOrUndefined) {
          const isShort = arguments.length <= 1;
          const body = isShort ? decoratorsOrBody : bodyOrUndefined;
          if (missingCreateClassStaticBlockDeclaration) {
            const node = factory.createEmptyStatement();
            node.body = body;
            node.transformFlags = 8388608;
            return node;
          } else {
            return ts4CastFactory.createClassStaticBlockDeclaration(void 0, void 0, body);
          }
        }
        function updateClassStaticBlockDeclaration(node, decoratorsOrBody, modifiersOrUndefined, bodyOrUndefined) {
          const isShort = arguments.length <= 2;
          const body = isShort ? decoratorsOrBody : bodyOrUndefined;
          if (missingCreateClassStaticBlockDeclaration) {
            return body === node.body ? node : update(createClassStaticBlockDeclaration(body), node);
          } else {
            return ts4CastFactory.updateClassStaticBlockDeclaration(node, void 0, void 0, body);
          }
        }
        function createClassExpression(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrTypeParameters;
          const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
          const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
          const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
          return factory.createClassExpression(
            decorators,
            modifiers,
            name,
            typeParameters,
            heritageClauses,
            members
          );
        }
        function updateClassExpression(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrTypeParameters;
          const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
          const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
          const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
          return factory.updateClassExpression(
            node,
            decorators,
            modifiers,
            name,
            typeParameters,
            heritageClauses,
            members
          );
        }
        function createFunctionDeclaration(decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
          const isShort = arguments.length <= 7;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
          const asteriskToken = isShort ? modifiersOrAsteriskToken : asteriskTokenOrName;
          const name = isShort ? asteriskTokenOrName : nameOrTypeParameters;
          const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrParameters;
          const parameters = isShort ? typeParametersOrParameters : parametersOrType;
          const type = isShort ? parametersOrType : typeOrBody;
          const body = isShort ? typeOrBody : bodyOrUndefined;
          return factory.createFunctionDeclaration(
            decorators,
            modifiers,
            asteriskToken,
            name,
            typeParameters,
            parameters,
            type,
            body
          );
        }
        function updateFunctionDeclaration(node, decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
          const isShort = arguments.length <= 8;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
          const asteriskToken = isShort ? modifiersOrAsteriskToken : asteriskTokenOrName;
          const name = isShort ? asteriskTokenOrName : nameOrTypeParameters;
          const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrParameters;
          const parameters = isShort ? typeParametersOrParameters : parametersOrType;
          const type = isShort ? parametersOrType : typeOrBody;
          const body = isShort ? typeOrBody : bodyOrUndefined;
          return factory.updateFunctionDeclaration(
            node,
            decorators,
            modifiers,
            asteriskToken,
            name,
            typeParameters,
            parameters,
            type,
            body
          );
        }
        function createClassDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
          const isShort = arguments.length <= 5;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrTypeParameters;
          const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
          const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
          const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
          return factory.createClassDeclaration(
            decorators,
            modifiers,
            name,
            typeParameters,
            heritageClauses,
            members
          );
        }
        function updateClassDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
          const isShort = arguments.length <= 6;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrTypeParameters;
          const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
          const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
          const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
          return factory.updateClassDeclaration(
            node,
            decorators,
            modifiers,
            name,
            typeParameters,
            heritageClauses,
            members
          );
        }
        function createInterfaceDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrTypeParameters;
          const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
          const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
          const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
          return factory.createInterfaceDeclaration(
            decorators,
            modifiers,
            name,
            typeParameters,
            heritageClauses,
            members
          );
        }
        function updateInterfaceDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrTypeParameters;
          const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
          const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
          const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
          return factory.updateInterfaceDeclaration(
            node,
            decorators,
            modifiers,
            name,
            typeParameters,
            heritageClauses,
            members
          );
        }
        function createTypeAliasDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrType, typeOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrTypeParameters;
          const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrType;
          const type = isShort ? typeParametersOrType : typeOrUndefined;
          return factory.createTypeAliasDeclaration(
            decorators,
            modifiers,
            name,
            typeParameters,
            type
          );
        }
        function updateTypeAliasDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrType, typeOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrTypeParameters;
          const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrType;
          const type = isShort ? typeParametersOrType : typeOrUndefined;
          return factory.updateTypeAliasDeclaration(
            node,
            decorators,
            modifiers,
            name,
            typeParameters,
            type
          );
        }
        function createEnumDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrMembers, membersOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrMembers;
          const members = isShort ? nameOrMembers : membersOrUndefined;
          return factory.createEnumDeclaration(
            decorators,
            modifiers,
            name,
            members
          );
        }
        function updateEnumDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrMembers, membersOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrMembers;
          const members = isShort ? nameOrMembers : membersOrUndefined;
          return factory.updateEnumDeclaration(
            node,
            decorators,
            modifiers,
            name,
            members
          );
        }
        function createModuleDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrBody, bodyOrFlags, flagsOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && ("escapedText" in modifiersOrName || "_literalExpressionBrand" in modifiersOrName);
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrBody;
          const body = isShort ? nameOrBody : bodyOrFlags;
          const flags = isShort ? bodyOrFlags : flagsOrUndefined;
          return factory.createModuleDeclaration(
            decorators,
            modifiers,
            name,
            body,
            flags
          );
        }
        function updateModuleDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrBody, bodyOrUndefined) {
          const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && ("escapedText" in modifiersOrName || "_literalExpressionBrand" in modifiersOrName);
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
          const name = isShort ? modifiersOrName : nameOrBody;
          const body = isShort ? nameOrBody : bodyOrUndefined;
          return factory.updateModuleDeclaration(
            node,
            decorators,
            modifiers,
            name,
            body
          );
        }
        function createImportEqualsDeclaration(decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
          const isShort = arguments.length <= 4;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
          const isTypeOnly = (isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrName) ?? false;
          const name = isShort ? isTypeOnlyOrName : nameOrModuleReference;
          const moduleReference = isShort ? nameOrModuleReference : moduleReferenceOrUndefined;
          if (badCreateImportEqualsDeclaration) {
            return factory.createImportEqualsDeclaration(
              decorators,
              modifiers,
              name,
              moduleReference
            );
          } else {
            return factory.createImportEqualsDeclaration(
              decorators,
              modifiers,
              isTypeOnly,
              name,
              moduleReference
            );
          }
        }
        function updateImportEqualsDeclaration(node, decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
          const isShort = arguments.length <= 5;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
          const isTypeOnly = isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrName;
          const name = isShort ? isTypeOnlyOrName : nameOrModuleReference;
          const moduleReference = isShort ? nameOrModuleReference : moduleReferenceOrUndefined;
          if (badCreateImportEqualsDeclaration) {
            return factory.updateImportEqualsDeclaration(
              node,
              decorators,
              modifiers,
              name,
              moduleReference
            );
          } else {
            return factory.updateImportEqualsDeclaration(
              node,
              decorators,
              modifiers,
              isTypeOnly,
              name,
              moduleReference
            );
          }
        }
        function createImportDeclaration(decoratorsOrModifiers, modifiersOrImportClause, importClauseOrModuleSpecifier, moduleSpecifierOrAttributes, _) {
          const isShort = importClauseOrModuleSpecifier != null && !("namedBindings" in importClauseOrModuleSpecifier) && !("isTypeOnly" in importClauseOrModuleSpecifier);
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrImportClause;
          const importClause = isShort ? modifiersOrImportClause : importClauseOrModuleSpecifier;
          const moduleSpecifier = isShort ? importClauseOrModuleSpecifier : moduleSpecifierOrAttributes;
          return factory.createImportDeclaration(
            decorators,
            modifiers,
            importClause,
            moduleSpecifier
          );
        }
        function updateImportDeclaration(node, decoratorsOrModifiers, modifiersOrImportClause, importClauseOrModuleSpecifier, moduleSpecifierOrAttributes, _) {
          const isShort = importClauseOrModuleSpecifier != null && !("namedBindings" in importClauseOrModuleSpecifier) && !("isTypeOnly" in importClauseOrModuleSpecifier);
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrImportClause;
          const importClause = isShort ? modifiersOrImportClause : importClauseOrModuleSpecifier;
          const moduleSpecifier = isShort ? importClauseOrModuleSpecifier : moduleSpecifierOrAttributes;
          return factory.updateImportDeclaration(
            node,
            decorators,
            modifiers,
            importClause,
            moduleSpecifier,
            void 0
          );
        }
        function createExportAssignment(decoratorsOrModifiers, modifiersOrIsExportEquals, isExportEqualsOrExpression, expressionOrUndefined) {
          const isShort = arguments.length <= 3;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsExportEquals;
          const isExportEquals = isShort ? modifiersOrIsExportEquals : isExportEqualsOrExpression;
          const expression = isShort ? isExportEqualsOrExpression : expressionOrUndefined;
          return factory.createExportAssignment(
            decorators,
            modifiers,
            isExportEquals,
            expression
          );
        }
        function updateExportAssignment(node, decoratorsOrModifiers, modifiersOrExpression, expressionOrUndefined) {
          const isShort = arguments.length <= 3;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrExpression;
          const expression = isShort ? modifiersOrExpression : expressionOrUndefined;
          return factory.updateExportAssignment(
            node,
            decorators,
            modifiers,
            expression
          );
        }
        function createExportDeclaration(decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrExportClause, exportClauseOrModuleSpecifier, moduleSpecifierOrImportAttributes, _) {
          const isLong = typeof modifiersOrIsTypeOnly !== "boolean" && (arguments.length >= 6 || Array.isArray(modifiersOrIsTypeOnly));
          const isShort = !isLong;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
          const isTypeOnly = isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrExportClause;
          const exportClause = isShort ? isTypeOnlyOrExportClause : exportClauseOrModuleSpecifier;
          const moduleSpecifier = isShort ? exportClauseOrModuleSpecifier : moduleSpecifierOrImportAttributes;
          return factory.createExportDeclaration(
            decorators,
            modifiers,
            isTypeOnly,
            exportClause,
            moduleSpecifier
          );
        }
        function updateExportDeclaration(node, decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrExportClause, exportClauseOrModuleSpecifier, moduleSpecifierOrAttributes, _) {
          const isLong = typeof modifiersOrIsTypeOnly !== "boolean" && (arguments.length >= 7 || Array.isArray(modifiersOrIsTypeOnly));
          const isShort = !isLong;
          const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
          const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
          const isTypeOnly = isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrExportClause;
          const exportClause = isShort ? isTypeOnlyOrExportClause : exportClauseOrModuleSpecifier;
          const moduleSpecifier = isShort ? exportClauseOrModuleSpecifier : moduleSpecifierOrAttributes;
          return factory.updateExportDeclaration(
            node,
            decorators,
            modifiers,
            isTypeOnly,
            exportClause,
            moduleSpecifier,
            void 0
          );
        }
        return {
          createParameterDeclaration,
          updateParameterDeclaration,
          createPropertyDeclaration,
          updatePropertyDeclaration,
          createMethodDeclaration,
          updateMethodDeclaration,
          createConstructorDeclaration,
          updateConstructorDeclaration,
          createGetAccessorDeclaration,
          updateGetAccessorDeclaration,
          createSetAccessorDeclaration,
          updateSetAccessorDeclaration,
          createIndexSignature,
          updateIndexSignature,
          createClassStaticBlockDeclaration,
          updateClassStaticBlockDeclaration,
          createClassExpression,
          updateClassExpression,
          createFunctionDeclaration,
          updateFunctionDeclaration,
          createClassDeclaration,
          updateClassDeclaration,
          createInterfaceDeclaration,
          updateInterfaceDeclaration,
          createTypeAliasDeclaration,
          updateTypeAliasDeclaration,
          createEnumDeclaration,
          updateEnumDeclaration,
          createModuleDeclaration,
          updateModuleDeclaration,
          createImportEqualsDeclaration,
          updateImportEqualsDeclaration,
          createImportDeclaration,
          updateImportDeclaration,
          createExportAssignment,
          updateExportAssignment,
          createExportDeclaration,
          updateExportDeclaration
        };
      })() : {}
    };
  }
  return factory;
}
function createNodeFactory(typescript) {
  const typescript4Cast = typescript;
  function createToken(token) {
    return typescript4Cast.createToken(token);
  }
  function createConstructorTypeNode(modifiersOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrUndefined) {
    if (arguments.length >= 4) {
      return typescript4Cast.createConstructorTypeNode(typeParametersOrParameters, parametersOrType, typeOrUndefined);
    }
    return typescript4Cast.createConstructorTypeNode(modifiersOrTypeParameters, typeParametersOrParameters, parametersOrType);
  }
  function updateConstructorTypeNode(node, modifiersOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrUndefined) {
    if (arguments.length >= 5) {
      return typescript4Cast.updateConstructorTypeNode(node, typeParametersOrParameters, parametersOrType, typeOrUndefined);
    }
    return typescript4Cast.updateConstructorTypeNode(node, modifiersOrTypeParameters, typeParametersOrParameters, parametersOrType);
  }
  function createNamedTupleMember(dotDotDotToken, name, questionToken, type) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.NamedTupleMember ?? typescript.SyntaxKind.TupleType);
    node.dotDotDotToken = dotDotDotToken;
    node.name = name;
    node.questionToken = questionToken;
    node.type = type;
    node.transformFlags = 1;
    return node;
  }
  function createJSDocComment(comment, tags) {
    if ("createJSDocComment" in typescript) {
      return typescript4Cast.createJSDocComment(comment, tags);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocComment);
    node.comment = comment;
    node.tags = typescript4Cast.createNodeArray(tags);
    return node;
  }
  function createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
    if ("createJSDocParameterTag" in typescript) {
      return typescript4Cast.createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocParameterTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.name = name;
    node.isBracketed = isBracketed;
    node.typeExpression = typeExpression;
    if (isNameFirst != null) node.isNameFirst = isNameFirst;
    node.comment = comment;
    return node;
  }
  function createJSDocPrivateTag(tagName, comment) {
    if ("createJSDocPrivateTag" in typescript) {
      return typescript4Cast.createJSDocPrivateTag(tagName, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocPrivateTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.comment = comment;
    return node;
  }
  function createJSDocAugmentsTag(tagName, className, comment) {
    if ("createJSDocAugmentsTag" in typescript) {
      return typescript4Cast.createJSDocAugmentsTag(tagName, className, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocAugmentsTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.class = className;
    node.comment = comment;
    return node;
  }
  function createJSDocDeprecatedTag(tagName, comment) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocDeprecatedTag ?? typescript.SyntaxKind.JSDocComment);
    node.tagName = tagName;
    node.comment = comment;
    return node;
  }
  function createJSDocFunctionType(parameters, type) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocFunctionType ?? typescript.SyntaxKind.JSDocComment);
    node.parameters = typescript4Cast.createNodeArray(parameters);
    node.type = type;
    return node;
  }
  function createJSDocLink(name, text) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocLink ?? typescript.SyntaxKind.JSDocComment);
    node.name = name;
    node.text = text;
    return node;
  }
  function createJSDocNameReference(name) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocNameReference ?? typescript.SyntaxKind.JSDocComment);
    node.name = name;
    return node;
  }
  function createJSDocNamepathType(type) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocNamepathType ?? typescript.SyntaxKind.JSDocComment);
    node.type = type;
    return node;
  }
  function createJSDocNonNullableType(type) {
    const node = typescript4Cast.createNode(
      typescript.SyntaxKind.JSDocNonNullableType ?? typescript.SyntaxKind.JSDocComment
    );
    node.type = type;
    return node;
  }
  function createJSDocNullableType(type) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocNullableType ?? typescript.SyntaxKind.JSDocComment);
    node.type = type;
    return node;
  }
  function createJSDocOptionalType(type) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocOptionalType ?? typescript.SyntaxKind.JSDocComment);
    node.type = type;
    return node;
  }
  function createJSDocOverrideTag(tagName, comment) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocOverrideTag ?? typescript.SyntaxKind.JSDocComment);
    node.tagName = tagName;
    node.comment = comment;
    return node;
  }
  function createJSDocSeeTag(tagName, nameExpression, comment) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocSeeTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) {
      node.tagName = tagName;
    }
    node.name = nameExpression;
    node.comment = comment;
    return node;
  }
  function createJSDocText(text) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocText ?? typescript.SyntaxKind.JSDocComment);
    node.text = text;
    return node;
  }
  function createJSDocUnknownTag(tagName, comment) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocTag ?? typescript.SyntaxKind.JSDocComment);
    node.tagName = tagName;
    node.comment = comment;
    return node;
  }
  function createJSDocUnknownType() {
    return typescript4Cast.createNode(typescript.SyntaxKind.JSDocUnknownType ?? typescript.SyntaxKind.JSDocComment);
  }
  function createJSDocVariadicType(type) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocVariadicType ?? typescript.SyntaxKind.JSDocComment);
    node.type = type;
    return node;
  }
  function createJSDocAllType() {
    return typescript4Cast.createNode(typescript.SyntaxKind.JSDocAllType ?? typescript.SyntaxKind.JSDocComment);
  }
  function createTemplateLiteralType(head, templateSpans) {
    const node = typescript4Cast.createNode(
      typescript.SyntaxKind.TemplateLiteralType ?? typescript.SyntaxKind.StringLiteral
    );
    node.head = head;
    node.templateSpans = typescript4Cast.createNodeArray(templateSpans);
    node.transformFlags = 1;
    return node;
  }
  function createTemplateLiteralTypeSpan(type, literal) {
    const node = typescript4Cast.createNode(
      typescript.SyntaxKind.TemplateLiteralTypeSpan ?? typescript.SyntaxKind.StringLiteral
    );
    node.type = type;
    node.literal = literal;
    node.transformFlags = 1;
    return node;
  }
  function createJSDocAuthorTag(tagName, comment) {
    if ("createJSDocAuthorTag" in typescript) {
      return typescript4Cast.createJSDocAuthorTag(tagName, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocAuthorTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.comment = comment;
    return node;
  }
  function createJSDocCallbackTag(tagName, typeExpression, fullName, comment) {
    if ("createJSDocCallbackTag" in typescript) {
      return typescript4Cast.createJSDocCallbackTag(tagName, typeExpression, fullName, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocCallbackTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.typeExpression = typeExpression;
    node.fullName = fullName;
    node.comment = comment;
    return node;
  }
  function createJSDocClassTag(tagName, comment) {
    if ("createJSDocClassTag" in typescript) {
      return typescript4Cast.createJSDocClassTag(tagName, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocClassTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.comment = comment;
    return node;
  }
  function createJSDocEnumTag(tagName, typeExpression, comment) {
    if ("createJSDocEnumTag" in typescript) {
      return typescript4Cast.createJSDocEnumTag(tagName, typeExpression, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocEnumTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.typeExpression = typeExpression;
    node.comment = comment;
    return node;
  }
  function createJSDocImplementsTag(tagName, className, comment) {
    if ("createJSDocImplementsTag" in typescript) {
      return typescript4Cast.createJSDocImplementsTag(tagName, className, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocImplementsTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.class = className;
    node.comment = comment;
    return node;
  }
  function createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
    if ("createJSDocPropertyTag" in typescript) {
      return typescript4Cast.createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocPropertyTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.name = name;
    node.isBracketed = isBracketed;
    node.typeExpression = typeExpression;
    if (isNameFirst != null) node.isNameFirst = isNameFirst;
    node.comment = comment;
    return node;
  }
  function createJSDocProtectedTag(tagName, comment) {
    if ("createJSDocProtectedTag" in typescript) {
      return typescript4Cast.createJSDocProtectedTag(tagName, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocProtectedTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.comment = comment;
    return node;
  }
  function createJSDocPublicTag(tagName, comment) {
    if ("createJSDocPublicTag" in typescript) {
      return typescript4Cast.createJSDocPublicTag(tagName, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocPublicTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.comment = comment;
    return node;
  }
  function createJSDocReadonlyTag(tagName, comment) {
    if ("createJSDocReadonlyTag" in typescript) {
      return typescript4Cast.createJSDocReadonlyTag(tagName, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocReadonlyTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.comment = comment;
    return node;
  }
  function createJSDocReturnTag(tagName, typeExpression, comment) {
    if ("createJSDocReturnTag" in typescript) {
      return typescript4Cast.createJSDocReturnTag(tagName, typeExpression, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocReturnTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.typeExpression = typeExpression;
    node.comment = comment;
    return node;
  }
  function createJSDocSignature(typeParameters, parameters, type) {
    if ("createJSDocSignature" in typescript) {
      return typescript4Cast.createJSDocSignature(typeParameters, parameters, type);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocSignature ?? typescript.SyntaxKind.JSDocComment);
    node.typeParameters = typeParameters;
    node.parameters = parameters;
    node.type = type;
    return node;
  }
  function createJSDocTemplateTag(tagName, constraint, typeParameters, comment) {
    if ("createJSDocTemplateTag" in typescript) {
      return typescript4Cast.createJSDocTemplateTag(tagName, constraint, typeParameters, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocTemplateTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.constraint = constraint;
    node.typeParameters = typescript4Cast.createNodeArray(typeParameters);
    node.comment = comment;
    return node;
  }
  function createJSDocThisTag(tagName, typeExpression, comment) {
    if ("createJSDocThisTag" in typescript) {
      return typescript4Cast.createJSDocThisTag(tagName, typeExpression, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocThisTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.typeExpression = typeExpression;
    node.comment = comment;
    return node;
  }
  function createJSDocTypeExpression(type) {
    if ("createJSDocTypeExpression" in typescript) {
      return typescript4Cast.createJSDocTypeExpression(type);
    }
    const node = typescript4Cast.createNode(
      typescript.SyntaxKind.JSDocTypeExpression ?? typescript.SyntaxKind.JSDocComment
    );
    node.type = type;
    return node;
  }
  function createJSDocTypeLiteral(jsDocPropertyTags, isArrayType) {
    if ("createJSDocTypeLiteral" in typescript) {
      return typescript4Cast.createJSDocTypeLiteral(jsDocPropertyTags, isArrayType);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocTypeLiteral ?? typescript.SyntaxKind.JSDocComment);
    node.jsDocPropertyTags = jsDocPropertyTags;
    if (isArrayType != null) node.isArrayType = isArrayType;
    return node;
  }
  function createJSDocTypeTag(tagName, typeExpression, comment) {
    if ("createJSDocTypeTag" in typescript) {
      return typescript4Cast.createJSDocTypeTag(tagName, typeExpression, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocTypeTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.typeExpression = typeExpression;
    node.comment = comment;
    return node;
  }
  function createJSDocTypedefTag(tagName, typeExpression, fullName, comment) {
    if ("createJSDocTypedefTag" in typescript) {
      return typescript4Cast.createJSDocTypedefTag(tagName, typeExpression, fullName, comment);
    }
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocTypedefTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.typeExpression = typeExpression;
    node.fullName = fullName;
    node.comment = comment;
    return node;
  }
  function createJSDocMemberName(left, right) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocMemberName ?? typescript.SyntaxKind.JSDocComment);
    node.left = left;
    node.right = right;
    return node;
  }
  function createJSDocLinkCode(name, text) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocLinkCode ?? typescript.SyntaxKind.JSDocComment);
    node.name = name;
    node.text = text;
    return node;
  }
  function createJSDocLinkPlain(name, text) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocLinkPlain ?? typescript.SyntaxKind.JSDocComment);
    node.name = name;
    node.text = text;
    return node;
  }
  function createJSDocOverloadTag(tagName, typeExpression, comment) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocOverloadTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.typeExpression = typeExpression;
    node.comment = comment;
    return node;
  }
  function createJSDocThrowsTag(tagName, typeExpression, comment) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocThrowsTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.typeExpression = typeExpression;
    node.comment = comment;
    return node;
  }
  function createJSDocSatisfiesTag(tagName, typeExpression, comment) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocSatisfiesTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.typeExpression = typeExpression;
    node.comment = comment;
    return node;
  }
  function createJSDocImportTag(tagName, importClause, moduleSpecifier, attributes, comment) {
    const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocImportTag ?? typescript.SyntaxKind.JSDocComment);
    if (tagName != null) node.tagName = tagName;
    node.comment = comment;
    node.importClause = importClause;
    node.moduleSpecifier = moduleSpecifier;
    node.attributes = attributes;
    return node;
  }
  function createClassStaticBlockDeclaration(decoratorsOrBody, modifiersOrUndefined, bodyOrUndefined) {
    const isShort = arguments.length <= 1;
    const body = isShort ? decoratorsOrBody : bodyOrUndefined;
    const node = typescript4Cast.createEmptyStatement();
    node.body = body;
    node.transformFlags = 8388608;
    return node;
  }
  function updateClassStaticBlockDeclaration(node, decoratorsOrBody, modifiersOrUndefined, bodyOrUndefined) {
    const isShort = arguments.length <= 2;
    const body = isShort ? decoratorsOrBody : bodyOrUndefined;
    return body === node.body ? node : typescript.setTextRange(createClassStaticBlockDeclaration(body), node);
  }
  function createSatisfiesExpression(expression, type) {
    return { ...expression };
  }
  function updateSatisfiesExpression(node, expression, type) {
    return expression === node.expression && type === node.type ? node : typescript.setTextRange(createSatisfiesExpression(expression, type), node);
  }
  function createAssertClause(elements, multiLine) {
    const node = typescript4Cast.createEmptyStatement();
    node.elements = elements;
    node.multiLine = multiLine;
    node.transformFlags |= 4;
    return node;
  }
  function createAssertEntry(name, value) {
    const node = typescript4Cast.createEmptyStatement();
    node.name = name;
    node.value = value;
    node.transformFlags |= 4;
    return node;
  }
  function createImportTypeAssertionContainer(clause, multiLine) {
    const node = typescript4Cast.createEmptyStatement();
    node.assertClause = clause;
    node.multiLine = multiLine;
    return node;
  }
  function createImportAttributes(elements, multiLine) {
    const node = typescript4Cast.createEmptyStatement();
    node.elements = elements;
    node.multiLine = multiLine;
    return node;
  }
  function createImportAttribute(name, value) {
    const node = typescript4Cast.createEmptyStatement();
    node.name = name;
    node.value = value;
    return node;
  }
  function createJsxNamespacedName(namespace, name) {
    const node = typescript4Cast.createEmptyStatement();
    node.namespace = namespace;
    node.name = name;
    return node;
  }
  function createImportTypeNode(argument, attributesOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined) {
    if ("createImportTypeNode" in typescript) {
      if (arguments.length < 5) {
        return typescript4Cast.createImportTypeNode(
          argument,
          attributesOrQualifier,
          qualifierOrTypeArguments,
          typeArgumentsOrIsTypeOf
        );
      } else {
        return typescript4Cast.createImportTypeNode(argument, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined);
      }
    } else {
      const attributes = attributesOrQualifier && "elements" in attributesOrQualifier ? attributesOrQualifier : void 0;
      const qualifier = attributesOrQualifier && typescript.isEntityName(attributesOrQualifier) ? attributesOrQualifier : qualifierOrTypeArguments && !Array.isArray(qualifierOrTypeArguments) ? qualifierOrTypeArguments : void 0;
      const typeArguments = Array.isArray(qualifierOrTypeArguments) ? qualifierOrTypeArguments : Array.isArray(typeArgumentsOrIsTypeOf) ? typeArgumentsOrIsTypeOf : void 0;
      isTypeOfOrUndefined = typeof typeArgumentsOrIsTypeOf === "boolean" ? typeArgumentsOrIsTypeOf : typeof isTypeOfOrUndefined === "boolean" ? isTypeOfOrUndefined : false;
      const node = typescript4Cast.createNode(200);
      node.argument = argument;
      node.attributes = attributes;
      node.qualifier = qualifier;
      node.typeArguments = typeArguments == null ? void 0 : typescript4Cast.createNodeArray(typeArguments);
      node.isTypeOf = isTypeOfOrUndefined;
      node.transformFlags = 1;
      return node;
    }
  }
  function updateImportTypeNode(node, argument, attributesOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined) {
    if ("updateImportTypeNode" in typescript) {
      if (arguments.length < 6) {
        return typescript4Cast.updateImportTypeNode(
          node,
          argument,
          attributesOrQualifier,
          qualifierOrTypeArguments,
          typeArgumentsOrIsTypeOf
        );
      } else {
        return typescript4Cast.updateImportTypeNode(
          node,
          argument,
          qualifierOrTypeArguments,
          typeArgumentsOrIsTypeOf,
          isTypeOfOrUndefined
        );
      }
    } else {
      const attributes = attributesOrQualifier && "elements" in attributesOrQualifier ? attributesOrQualifier : void 0;
      const qualifier = attributesOrQualifier && typescript.isEntityName(attributesOrQualifier) ? attributesOrQualifier : qualifierOrTypeArguments && !Array.isArray(qualifierOrTypeArguments) ? qualifierOrTypeArguments : void 0;
      const typeArguments = Array.isArray(qualifierOrTypeArguments) ? qualifierOrTypeArguments : Array.isArray(typeArgumentsOrIsTypeOf) ? typeArgumentsOrIsTypeOf : void 0;
      isTypeOfOrUndefined = typeof typeArgumentsOrIsTypeOf === "boolean" ? typeArgumentsOrIsTypeOf : typeof isTypeOfOrUndefined === "boolean" ? isTypeOfOrUndefined : node.isTypeOf;
      return node.argument !== argument || node.attributes !== attributes || node.qualifier !== qualifier || node.typeArguments !== typeArguments || node.isTypeOf !== isTypeOfOrUndefined ? typescript.setTextRange(
        createImportTypeNode(argument, attributesOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined),
        node
      ) : node;
    }
  }
  function createClassExpression(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrTypeParameters;
    const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
    const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
    const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
    return typescript4Cast.createClassExpression(modifiers, name, typeParameters, heritageClauses, members);
  }
  function updateClassExpression(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrTypeParameters;
    const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
    const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
    const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
    return typescript4Cast.updateClassExpression(node, modifiers, name, typeParameters, heritageClauses, members);
  }
  function createExportDeclaration(decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrExportClause, exportClauseOrModuleSpecifier, moduleSpecifierOrUndefined) {
    const isLong = typeof modifiersOrIsTypeOnly !== "boolean" && (arguments.length >= 6 || Array.isArray(modifiersOrIsTypeOnly));
    const isShort = !isLong;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
    const isTypeOnly = isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrExportClause;
    const exportClause = isShort ? isTypeOnlyOrExportClause : exportClauseOrModuleSpecifier;
    const moduleSpecifier = isShort ? exportClauseOrModuleSpecifier : moduleSpecifierOrUndefined;
    return typescript4Cast.createExportDeclaration(decorators, modifiers, exportClause, moduleSpecifier, isTypeOnly);
  }
  function updateExportDeclaration(node, decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrExportClause, exportClauseOrModuleSpecifier, moduleSpecifierOrUndefined) {
    const isLong = typeof modifiersOrIsTypeOnly !== "boolean" && (arguments.length >= 7 || Array.isArray(modifiersOrIsTypeOnly));
    const isShort = !isLong;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
    const isTypeOnly = isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrExportClause;
    const exportClause = isShort ? isTypeOnlyOrExportClause : exportClauseOrModuleSpecifier;
    const moduleSpecifier = isShort ? exportClauseOrModuleSpecifier : moduleSpecifierOrUndefined;
    return typescript4Cast.updateExportDeclaration(node, decorators, modifiers, exportClause, moduleSpecifier, isTypeOnly);
  }
  function createConstructorDeclaration(decoratorsOrModifiers, modifiersOrParameters, parametersOrBody, bodyOrUndefined) {
    const isShort = arguments.length <= 3;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
    const parameters = isShort ? modifiersOrParameters : parametersOrBody;
    const body = isShort ? parametersOrBody : bodyOrUndefined;
    return typescript4Cast.createConstructor(decorators, modifiers, parameters, body);
  }
  function updateConstructorDeclaration(node, decoratorsOrModifiers, modifiersOrParameters, parametersOrBody, bodyOrUndefined) {
    const isShort = arguments.length <= 4;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
    const parameters = isShort ? modifiersOrParameters : parametersOrBody;
    const body = isShort ? parametersOrBody : bodyOrUndefined;
    return typescript4Cast.updateConstructor(node, decorators, modifiers, parameters, body);
  }
  function createMethodDeclaration(decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrQuestionToken, questionTokenOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
    const isShort = typeof asteriskTokenOrName === "string" || asteriskTokenOrName != null && asteriskTokenOrName.kind !== 41;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
    const asteriskToken = isShort ? modifiersOrAsteriskToken : asteriskTokenOrName;
    const name = isShort ? asteriskTokenOrName : nameOrQuestionToken;
    const questionToken = isShort ? nameOrQuestionToken : questionTokenOrTypeParameters;
    const typeParameters = isShort ? questionTokenOrTypeParameters : typeParametersOrParameters;
    const parameters = isShort ? typeParametersOrParameters : parametersOrType;
    const type = isShort ? parametersOrType : typeOrBody;
    const body = isShort ? typeOrBody : bodyOrUndefined;
    return typescript4Cast.createMethod(
      decorators,
      modifiers,
      asteriskToken,
      name,
      questionToken,
      typeParameters,
      parameters,
      type,
      body
    );
  }
  function updateMethodDeclaration(node, decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrQuestionToken, questionTokenOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
    const isShort = asteriskTokenOrName?.kind !== 41;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
    const asteriskToken = isShort ? modifiersOrAsteriskToken : asteriskTokenOrName;
    const name = isShort ? asteriskTokenOrName : nameOrQuestionToken;
    const questionToken = isShort ? nameOrQuestionToken : questionTokenOrTypeParameters;
    const typeParameters = isShort ? questionTokenOrTypeParameters : typeParametersOrParameters;
    const parameters = isShort ? typeParametersOrParameters : parametersOrType;
    const type = isShort ? parametersOrType : typeOrBody;
    const body = isShort ? typeOrBody : bodyOrUndefined;
    return typescript4Cast.updateMethod(
      node,
      decorators,
      modifiers,
      asteriskToken,
      name,
      questionToken,
      typeParameters,
      parameters,
      type,
      body
    );
  }
  function createParameterDeclaration(decoratorsOrModifiers, modifiersOrDotDotDotToken, dotDotDotTokenOrName, nameOrQuestionToken, questionTokenOrType, typeOrInitializer, initializerOrUndefined) {
    const isShort = typeof dotDotDotTokenOrName === "string" || dotDotDotTokenOrName != null && dotDotDotTokenOrName.kind !== 25;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrDotDotDotToken;
    const dotDotDotToken = isShort ? modifiersOrDotDotDotToken : dotDotDotTokenOrName;
    const name = isShort ? dotDotDotTokenOrName : nameOrQuestionToken;
    const questionToken = isShort ? nameOrQuestionToken : questionTokenOrType;
    const type = isShort ? questionTokenOrType : typeOrInitializer;
    const initializer = isShort ? typeOrInitializer : initializerOrUndefined;
    return typescript4Cast.createParameter(
      decorators,
      modifiers,
      dotDotDotToken,
      name,
      questionToken,
      type,
      initializer
    );
  }
  function updateParameterDeclaration(node, decoratorsOrModifiers, modifiersOrDotDotDotToken, dotDotDotTokenOrName, nameOrQuestionToken, questionTokenOrType, typeOrInitializer, initializerOrUndefined) {
    const isShort = typeof dotDotDotTokenOrName === "string" || dotDotDotTokenOrName != null && dotDotDotTokenOrName.kind !== 25;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrDotDotDotToken;
    const dotDotDotToken = isShort ? modifiersOrDotDotDotToken : dotDotDotTokenOrName;
    const name = isShort ? dotDotDotTokenOrName : nameOrQuestionToken;
    const questionToken = isShort ? nameOrQuestionToken : questionTokenOrType;
    const type = isShort ? questionTokenOrType : typeOrInitializer;
    const initializer = isShort ? typeOrInitializer : initializerOrUndefined;
    return typescript4Cast.updateParameter(
      node,
      decorators,
      modifiers,
      dotDotDotToken,
      name,
      questionToken,
      type,
      initializer
    );
  }
  function createPropertyDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrQuestionOrExclamationToken, questionOrExclamationTokenOrType, typeOrInitializer, initializerOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrQuestionOrExclamationToken;
    const questionOrExclamationToken = isShort ? nameOrQuestionOrExclamationToken : questionOrExclamationTokenOrType;
    const type = isShort ? questionOrExclamationTokenOrType : typeOrInitializer;
    const initializer = isShort ? typeOrInitializer : initializerOrUndefined;
    return typescript4Cast.createProperty(
      decorators,
      modifiers,
      name,
      questionOrExclamationToken,
      type,
      initializer
    );
  }
  function updatePropertyDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrQuestionOrExclamationToken, questionOrExclamationTokenOrType, typeOrInitializer, initializerOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrQuestionOrExclamationToken;
    const questionOrExclamationToken = isShort ? nameOrQuestionOrExclamationToken : questionOrExclamationTokenOrType;
    const type = isShort ? questionOrExclamationTokenOrType : typeOrInitializer;
    const initializer = isShort ? typeOrInitializer : initializerOrUndefined;
    return typescript4Cast.updateProperty(
      node,
      decorators,
      modifiers,
      name,
      questionOrExclamationToken,
      type,
      initializer
    );
  }
  function createSetAccessorDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrBody, bodyOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrParameters;
    const parameters = isShort ? nameOrParameters : parametersOrBody;
    const body = isShort ? parametersOrBody : bodyOrUndefined;
    return typescript4Cast.createSetAccessor(decorators, modifiers, name, parameters, body);
  }
  function updateSetAccessorDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrBody, bodyOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrParameters;
    const parameters = isShort ? nameOrParameters : parametersOrBody;
    const body = isShort ? parametersOrBody : bodyOrUndefined;
    return typescript4Cast.updateSetAccessor(node, decorators, modifiers, name, parameters, body);
  }
  function createGetAccessorDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrParameters;
    const parameters = isShort ? nameOrParameters : parametersOrType;
    const type = isShort ? parametersOrType : typeOrBody;
    const body = isShort ? typeOrBody : bodyOrUndefined;
    return typescript4Cast.createGetAccessor(decorators, modifiers, name, parameters, type, body);
  }
  function updateGetAccessorDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName);
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrParameters;
    const parameters = isShort ? nameOrParameters : parametersOrType;
    const type = isShort ? parametersOrType : typeOrBody;
    const body = isShort ? typeOrBody : bodyOrUndefined;
    return typescript4Cast.updateGetAccessor(node, decorators, modifiers, name, parameters, type, body);
  }
  function createImportEqualsDeclaration(decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
    const isShort = arguments.length <= 4;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
    const isTypeOnly = isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrName;
    const name = isShort ? isTypeOnlyOrName : nameOrModuleReference;
    const moduleReference = isShort ? nameOrModuleReference : moduleReferenceOrUndefined;
    if (typescript4Cast.createImportEqualsDeclaration.length === 4) {
      return typescript.createImportEqualsDeclaration(
        decorators,
        modifiers,
        name,
        moduleReference
      );
    } else {
      const normalizedName = typeof name === "string" ? typescript4Cast.createIdentifier(name) : name;
      return typescript4Cast.createImportEqualsDeclaration(
        decorators,
        modifiers,
        isTypeOnly,
        normalizedName,
        moduleReference
      );
    }
  }
  function updateImportEqualsDeclaration(node, decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
    const isShort = arguments.length <= 5;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
    const isTypeOnly = isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrName;
    const name = isShort ? isTypeOnlyOrName : nameOrModuleReference;
    const moduleReference = isShort ? nameOrModuleReference : moduleReferenceOrUndefined;
    const normalizedName = typeof name === "string" ? typescript4Cast.createIdentifier(name) : name;
    if (typescript4Cast.updateImportEqualsDeclaration.length === 5) {
      return typescript.updateImportEqualsDeclaration(
        node,
        decorators,
        modifiers,
        normalizedName,
        moduleReference
      );
    } else {
      return typescript4Cast.updateImportEqualsDeclaration(
        node,
        decorators,
        modifiers,
        isTypeOnly,
        normalizedName,
        moduleReference
      );
    }
  }
  function createIndexSignature(decoratorsOrModifiers, modifiersOrParameters, parametersOrType, typeOrUndefined) {
    const isShort = arguments.length <= 3;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
    const parameters = isShort ? modifiersOrParameters : parametersOrType;
    const type = isShort ? parametersOrType : typeOrUndefined;
    return typescript4Cast.createIndexSignature(decorators, modifiers, parameters, type);
  }
  function updateIndexSignature(node, decoratorsOrModifiers, modifiersOrParameters, parametersOrType, typeOrUndefined) {
    const isShort = arguments.length <= 4;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
    const parameters = isShort ? modifiersOrParameters : parametersOrType;
    const type = isShort ? parametersOrType : typeOrUndefined;
    return typescript4Cast.updateIndexSignature(node, decorators, modifiers, parameters, type);
  }
  function createImportDeclaration(decoratorsOrModifiers, modifiersOrImportClause, importClauseOrModuleSpecifier, moduleSpecifierOrAttributes, _) {
    const isShort = importClauseOrModuleSpecifier != null && !("namedBindings" in importClauseOrModuleSpecifier) && !("isTypeOnly" in importClauseOrModuleSpecifier);
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrImportClause;
    const importClause = isShort ? modifiersOrImportClause : importClauseOrModuleSpecifier;
    const moduleSpecifier = isShort ? importClauseOrModuleSpecifier : moduleSpecifierOrAttributes;
    return typescript4Cast.createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier);
  }
  function updateImportDeclaration(node, decoratorsOrModifiers, modifiersOrImportClause, importClauseOrModuleSpecifier, moduleSpecifierOrAttributes, _) {
    const isShort = importClauseOrModuleSpecifier != null && !("namedBindings" in importClauseOrModuleSpecifier) && !("isTypeOnly" in importClauseOrModuleSpecifier);
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrImportClause;
    const importClause = isShort ? modifiersOrImportClause : importClauseOrModuleSpecifier;
    const moduleSpecifier = isShort ? importClauseOrModuleSpecifier : moduleSpecifierOrAttributes;
    return typescript4Cast.updateImportDeclaration(
      node,
      decorators,
      modifiers,
      importClause,
      moduleSpecifier,
      void 0
    );
  }
  const createPrivateIdentifier = typescript4Cast.createPrivateIdentifier ?? /* @__PURE__ */ (() => function(text) {
    const node = typescript4Cast.createIdentifier(text);
    return node;
  })();
  function createUniquePrivateName(text) {
    if (text != null && !text.startsWith("#")) {
      throw new TypeError("First character of private identifier must be #: " + text);
    }
    const node = createPrivateIdentifier(text ?? "");
    return node;
  }
  function getGeneratedPrivateNameForNode(node) {
    return createPrivateIdentifier("");
  }
  function createTypeAliasDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrType, typeOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrTypeParameters;
    const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrType;
    const type = isShort ? typeParametersOrType : typeOrUndefined;
    return typescript4Cast.createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type);
  }
  function updateTypeAliasDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrType, typeOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrTypeParameters;
    const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrType;
    const type = isShort ? typeParametersOrType : typeOrUndefined;
    return typescript4Cast.updateTypeAliasDeclaration(node, decorators, modifiers, name, typeParameters, type);
  }
  function createFunctionDeclaration(decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
    const isShort = arguments.length <= 7;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
    const asteriskToken = isShort ? modifiersOrAsteriskToken : asteriskTokenOrName;
    const name = isShort ? asteriskTokenOrName : nameOrTypeParameters;
    const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrParameters;
    const parameters = isShort ? typeParametersOrParameters : parametersOrType;
    const type = isShort ? parametersOrType : typeOrBody;
    const body = isShort ? typeOrBody : bodyOrUndefined;
    return typescript4Cast.createFunctionDeclaration(
      decorators,
      modifiers,
      asteriskToken,
      name,
      typeParameters,
      parameters,
      type,
      body
    );
  }
  function updateFunctionDeclaration(node, decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
    const isShort = arguments.length <= 8;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
    const asteriskToken = isShort ? modifiersOrAsteriskToken : asteriskTokenOrName;
    const name = isShort ? asteriskTokenOrName : nameOrTypeParameters;
    const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrParameters;
    const parameters = isShort ? typeParametersOrParameters : parametersOrType;
    const type = isShort ? parametersOrType : typeOrBody;
    const body = isShort ? typeOrBody : bodyOrUndefined;
    return typescript4Cast.updateFunctionDeclaration(
      node,
      decorators,
      modifiers,
      asteriskToken,
      name,
      typeParameters,
      parameters,
      type,
      body
    );
  }
  function createClassDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
    const isShort = arguments.length <= 5;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrTypeParameters;
    const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
    const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
    const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
    return typescript4Cast.createClassDeclaration(
      decorators,
      modifiers,
      name,
      typeParameters,
      heritageClauses,
      members
    );
  }
  function updateClassDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
    const isShort = arguments.length <= 6;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrTypeParameters;
    const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
    const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
    const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
    return typescript4Cast.updateClassDeclaration(
      node,
      decorators,
      modifiers,
      name,
      typeParameters,
      heritageClauses,
      members
    );
  }
  function createInterfaceDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrTypeParameters;
    const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
    const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
    const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
    return typescript4Cast.createInterfaceDeclaration(
      decorators,
      modifiers,
      name,
      typeParameters,
      heritageClauses,
      members
    );
  }
  function updateInterfaceDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrTypeParameters;
    const typeParameters = isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses;
    const heritageClauses = isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers;
    const members = isShort ? heritageClausesOrMembers : membersOrUndefined;
    return typescript4Cast.updateInterfaceDeclaration(
      node,
      decorators,
      modifiers,
      name,
      typeParameters,
      heritageClauses,
      members
    );
  }
  function createEnumDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrMembers, membersOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrMembers;
    const members = isShort ? nameOrMembers : membersOrUndefined;
    return typescript4Cast.createEnumDeclaration(decorators, modifiers, name, members);
  }
  function updateEnumDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrMembers, membersOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrMembers;
    const members = isShort ? nameOrMembers : membersOrUndefined;
    return typescript4Cast.updateEnumDeclaration(node, decorators, modifiers, name, members);
  }
  function createModuleDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrBody, bodyOrFlags, flagsOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && ("escapedText" in modifiersOrName || "_literalExpressionBrand" in modifiersOrName);
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrBody;
    const body = isShort ? nameOrBody : bodyOrFlags;
    const flags = isShort ? bodyOrFlags : flagsOrUndefined;
    return typescript4Cast.createModuleDeclaration(decorators, modifiers, name, body, flags);
  }
  function updateModuleDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrBody, bodyOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && ("escapedText" in modifiersOrName || "_literalExpressionBrand" in modifiersOrName);
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrBody;
    const body = isShort ? nameOrBody : bodyOrUndefined;
    return typescript4Cast.updateModuleDeclaration(node, decorators, modifiers, name, body);
  }
  function createExportAssignment(decoratorsOrModifiers, modifiersOrIsExportEquals, isExportEqualsOrExpression, expressionOrUndefined) {
    const isShort = arguments.length <= 3;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsExportEquals;
    const isExportEquals = isShort ? modifiersOrIsExportEquals : isExportEqualsOrExpression;
    const expression = isShort ? isExportEqualsOrExpression : expressionOrUndefined;
    return typescript4Cast.createExportAssignment(decorators, modifiers, isExportEquals, expression);
  }
  function updateExportAssignment(node, decoratorsOrModifiers, modifiersOrExpression, expressionOrUndefined) {
    const isShort = arguments.length <= 3;
    const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
    const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrExpression;
    const expression = isShort ? modifiersOrExpression : expressionOrUndefined;
    return typescript4Cast.updateExportAssignment(node, decorators, modifiers, expression);
  }
  function createTypeParameterDeclaration(modifiersOrName, nameOrConstraint, constraintOrDefaultType, defaultTypeOrUndefined) {
    const isShort = typeof modifiersOrName === "string" || modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
    const modifiers = isShort ? void 0 : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrConstraint;
    const constraint = isShort ? nameOrConstraint : constraintOrDefaultType;
    const defaultType = isShort ? constraintOrDefaultType : defaultTypeOrUndefined;
    const typeParameterDeclaration = typescript4Cast.createTypeParameterDeclaration(
      name,
      constraint,
      defaultType
    );
    if (modifiers != null) {
      typeParameterDeclaration.modifiers = typescript4Cast.createNodeArray(modifiers);
    }
    return typeParameterDeclaration;
  }
  function updateTypeParameterDeclaration(node, modifiersOrName, nameOrConstraint, constraintOrDefaultType, defaultTypeOrUndefined) {
    const isShort = modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName;
    const modifiers = isShort ? void 0 : modifiersOrName;
    const name = isShort ? modifiersOrName : nameOrConstraint;
    const constraint = isShort ? nameOrConstraint : constraintOrDefaultType;
    const defaultType = isShort ? constraintOrDefaultType : defaultTypeOrUndefined;
    const typeParameterDeclaration = typescript4Cast.updateTypeParameterDeclaration(
      node,
      name,
      constraint,
      defaultType
    );
    if (modifiers != null) {
      typeParameterDeclaration.modifiers = typescript4Cast.createNodeArray(modifiers);
    }
    return typeParameterDeclaration;
  }
  const { updateSourceFileNode, ...common } = typescript;
  return {
    ["__compatUpgraded"]: true,
    ...common,
    createToken,
    createConstructorTypeNode,
    updateConstructorTypeNode,
    createImportTypeNode,
    updateImportTypeNode,
    createJSDocComment,
    createJSDocParameterTag,
    createJSDocPrivateTag,
    createJSDocAugmentsTag,
    createJSDocAuthorTag,
    createJSDocCallbackTag,
    createJSDocClassTag,
    createJSDocEnumTag,
    createJSDocImplementsTag,
    createJSDocPropertyTag,
    createJSDocProtectedTag,
    createJSDocPublicTag,
    createJSDocReadonlyTag,
    createJSDocReturnTag,
    createJSDocSignature,
    createJSDocTemplateTag,
    createJSDocThisTag,
    createJSDocTypeExpression,
    createJSDocTypeLiteral,
    createJSDocTypeTag,
    createJSDocTypedefTag,
    createJSDocAllType,
    createJSDocDeprecatedTag,
    createJSDocFunctionType,
    createJSDocLink,
    createJSDocNameReference,
    createJSDocNamepathType,
    createJSDocNonNullableType,
    createJSDocNullableType,
    createJSDocOptionalType,
    createJSDocOverrideTag,
    createJSDocSeeTag,
    createJSDocText,
    createJSDocUnknownTag,
    createJSDocUnknownType,
    createJSDocVariadicType,
    createJSDocMemberName,
    createJSDocLinkCode,
    createJSDocLinkPlain,
    createJSDocOverloadTag,
    createJSDocThrowsTag,
    createJSDocSatisfiesTag,
    createJSDocImportTag,
    createTemplateLiteralType,
    createTemplateLiteralTypeSpan,
    createClassStaticBlockDeclaration,
    createAssertClause,
    createAssertEntry,
    createImportTypeAssertionContainer,
    createImportAttributes,
    createImportAttribute,
    createJsxNamespacedName,
    createIndexSignature,
    updateIndexSignature,
    createSatisfiesExpression,
    updateSatisfiesExpression,
    createImportDeclaration,
    updateImportDeclaration,
    createUniquePrivateName,
    createPrivateIdentifier,
    getGeneratedPrivateNameForNode,
    createTypeAliasDeclaration,
    updateTypeAliasDeclaration,
    createFunctionDeclaration,
    updateFunctionDeclaration,
    createClassDeclaration,
    updateClassDeclaration,
    createInterfaceDeclaration,
    updateInterfaceDeclaration,
    createEnumDeclaration,
    updateEnumDeclaration,
    createModuleDeclaration,
    updateModuleDeclaration,
    createExportAssignment,
    updateExportAssignment,
    createTypeParameterDeclaration,
    updateTypeParameterDeclaration,
    createComma(left, right) {
      return typescript4Cast.createComma(left, right);
    },
    createAssignment(left, right) {
      return typescript4Cast.createAssignment(left, right);
    },
    createLessThan(left, right) {
      return typescript4Cast.createLessThan(left, right);
    },
    createSourceFile(statements, endOfFileToken, flags) {
      const sourceFile = typescript.createSourceFile("", "", 0, void 0, 0);
      sourceFile.endOfFileToken = endOfFileToken;
      sourceFile.flags |= flags;
      sourceFile.statements = typescript4Cast.createNodeArray(statements);
      return sourceFile;
    },
    createClassExpression,
    createExpressionWithTypeArguments(expression, typeArguments) {
      return typescript4Cast.createExpressionWithTypeArguments(typeArguments, expression);
    },
    updateExpressionWithTypeArguments(node, expression, typeArguments) {
      return typescript4Cast.updateExpressionWithTypeArguments(node, typeArguments, expression);
    },
    updateImportClause(node, isTypeOnly, name, namedBindings) {
      return typescript4Cast.updateImportClause(node, name, namedBindings, isTypeOnly);
    },
    updateExportDeclaration,
    createTypePredicateNode(assertsModifier, parameterName, type) {
      return typescript4Cast.createTypePredicateNode(parameterName, type);
    },
    updateTypePredicateNode(node, assertsModifier, parameterName, type) {
      return typescript4Cast.updateTypePredicateNode(node, parameterName, type);
    },
    createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type) {
      const methodSignature = typescript4Cast.createMethodSignature(
        typeParameters,
        parameters,
        type,
        name,
        questionToken
      );
      if (modifiers != null) {
        methodSignature.modifiers = typescript4Cast.createNodeArray(modifiers);
      }
      return methodSignature;
    },
    updateMethodSignature(node, modifiers, name, questionToken, typeParameters, parameters, type) {
      const methodSignature = typescript4Cast.updateMethodSignature(
        node,
        typeParameters,
        parameters,
        type,
        name,
        questionToken
      );
      if (modifiers !== methodSignature.modifiers) {
        methodSignature.modifiers = modifiers == null ? modifiers : typescript4Cast.createNodeArray(modifiers);
      }
      return methodSignature;
    },
    updatePropertySignature(node, modifiers, name, questionToken, type) {
      return typescript4Cast.updatePropertySignature(node, modifiers, name, questionToken, type, void 0);
    },
    createAwaitExpression(expression) {
      return typescript4Cast.createAwait(expression);
    },
    createBinaryExpression(left, operator, right) {
      return typescript4Cast.createBinary(left, operator, right);
    },
    createBitwiseAnd(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.AmpersandToken, right);
    },
    createBitwiseNot(operand) {
      return typescript4Cast.createPrefix(typescript.SyntaxKind.TildeToken, operand);
    },
    createBitwiseOr(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.BarToken, right);
    },
    createBitwiseXor(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.CaretToken, right);
    },
    createBreakStatement(label) {
      return typescript4Cast.createBreak(label);
    },
    createCommaListExpression(elements) {
      return typescript4Cast.createCommaList(elements);
    },
    createConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse) {
      if (questionToken == null || colonToken == null) {
        return typescript4Cast.createConditional(condition, whenTrue, whenFalse);
      }
      return typescript4Cast.createConditional(condition, questionToken, whenTrue, colonToken, whenFalse);
    },
    createConstructorDeclaration,
    createContinueStatement(label) {
      return typescript4Cast.createContinue(label);
    },
    createDeleteExpression(expression) {
      return typescript4Cast.createDelete(expression);
    },
    createDivide(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.SlashToken, right);
    },
    createDoStatement(statement, expression) {
      return typescript4Cast.createDo(statement, expression);
    },
    createElementAccessExpression(expression, index) {
      return typescript4Cast.createElementAccess(expression, index);
    },
    createEquality(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.EqualsEqualsToken, right);
    },
    createExponent(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.AsteriskAsteriskToken, right);
    },
    createForInStatement(initializer, expression, statement) {
      return typescript4Cast.createForIn(initializer, expression, statement);
    },
    createForOfStatement(awaitModifier, initializer, expression, statement) {
      return typescript4Cast.createForOf(awaitModifier, initializer, expression, statement);
    },
    createForStatement(initializer, condition, incrementor, statement) {
      return typescript4Cast.createFor(initializer, condition, incrementor, statement);
    },
    createGreaterThan(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.GreaterThanToken, right);
    },
    createGreaterThanEquals(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.GreaterThanEqualsToken, right);
    },
    createIfStatement(expression, thenStatement, elseStatement) {
      return typescript4Cast.createIf(expression, thenStatement, elseStatement);
    },
    createInequality(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.ExclamationEqualsToken, right);
    },
    createLabeledStatement(label, statement) {
      return typescript4Cast.createLabel(label, statement);
    },
    createLeftShift(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.LessThanLessThanToken, right);
    },
    createLessThanEquals(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.LessThanEqualsToken, right);
    },
    createMethodDeclaration,
    createModulo(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.PercentToken, right);
    },
    createMultiply(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.AsteriskToken, right);
    },
    createNamedTupleMember,
    createNewExpression(expression, typeArguments, argumentsArray) {
      return typescript4Cast.createNew(expression, typeArguments, argumentsArray);
    },
    createParameterDeclaration,
    createParenthesizedExpression(expression) {
      return typescript4Cast.createParen(expression);
    },
    createPostfixDecrement(operand) {
      return typescript4Cast.createPostfix(operand, typescript.SyntaxKind.MinusMinusToken);
    },
    createPostfixUnaryExpression(operand, operator) {
      return typescript4Cast.createPostfix(operand, operator);
    },
    createPrefixDecrement(operand) {
      return typescript4Cast.createPrefix(typescript.SyntaxKind.MinusMinusToken, operand);
    },
    createPrefixIncrement(operand) {
      return typescript4Cast.createPrefix(typescript.SyntaxKind.PlusPlusToken, operand);
    },
    createPrefixMinus(operand) {
      return typescript4Cast.createPrefix(typescript.SyntaxKind.MinusToken, operand);
    },
    createPrefixPlus(operand) {
      return typescript4Cast.createPrefix(typescript.SyntaxKind.PlusToken, operand);
    },
    createPrefixUnaryExpression(operator, operand) {
      return typescript4Cast.createPrefix(operator, operand);
    },
    createPropertyDeclaration,
    createRightShift(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.GreaterThanGreaterThanToken, right);
    },
    createSetAccessorDeclaration,
    createSpreadElement(expression) {
      return typescript4Cast.createSpread(expression);
    },
    createSwitchStatement(expression, caseBlock) {
      return typescript4Cast.createSwitch(expression, caseBlock);
    },
    createTaggedTemplateExpression(tag, typeArguments, template) {
      return typescript4Cast.createTaggedTemplate(tag, typeArguments, template);
    },
    createThrowStatement(expression) {
      return typescript4Cast.createThrow(expression);
    },
    createTryStatement(tryBlock, catchClause, finallyBlock) {
      return typescript4Cast.createTry(tryBlock, catchClause, finallyBlock);
    },
    createTypeOfExpression(expression) {
      return typescript4Cast.createTypeOf(expression);
    },
    createUnsignedRightShift(left, right) {
      return typescript4Cast.createBinary(left, typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, right);
    },
    createVoidExpression(expression) {
      return typescript4Cast.createVoid(expression);
    },
    createWhileStatement(expression, statement) {
      return typescript4Cast.createWhile(expression, statement);
    },
    createWithStatement(expression, statement) {
      return typescript4Cast.createWith(expression, statement);
    },
    createYieldExpression(asteriskToken, expression) {
      return typescript4Cast.createYield(asteriskToken, expression);
    },
    restoreOuterExpressions(outerExpression, innerExpression, kinds) {
      return innerExpression;
    },
    updateAwaitExpression(node, expression) {
      return typescript4Cast.updateAwait(node, expression);
    },
    updateBinaryExpression(node, left, operator, right) {
      return typescript4Cast.updateBinary(node, left, right, operator);
    },
    updateBreakStatement(node, label) {
      return typescript4Cast.updateBreak(node, label);
    },
    updateCommaListExpression(node, elements) {
      return typescript4Cast.updateCommaList(node, elements);
    },
    updateConditionalExpression(node, condition, questionToken, whenTrue, colonToken, whenFalse) {
      return typescript4Cast.updateConditional(node, condition, questionToken, whenTrue, colonToken, whenFalse);
    },
    updateContinueStatement(node, label) {
      return typescript4Cast.updateContinue(node, label);
    },
    updateDeleteExpression(node, expression) {
      return typescript4Cast.updateDelete(node, expression);
    },
    updateDoStatement(node, statement, expression) {
      return typescript4Cast.updateDo(node, statement, expression);
    },
    updateElementAccessExpression(node, expression, argumentExpression) {
      return typescript4Cast.updateElementAccess(node, expression, argumentExpression);
    },
    updateForInStatement(node, initializer, expression, statement) {
      return typescript4Cast.updateForIn(node, initializer, expression, statement);
    },
    updateForOfStatement(node, awaitModifier, initializer, expression, statement) {
      return typescript4Cast.updateForOf(node, awaitModifier, initializer, expression, statement);
    },
    updateForStatement(node, initializer, condition, incrementor, statement) {
      return typescript4Cast.updateFor(node, initializer, condition, incrementor, statement);
    },
    updateIfStatement(node, expression, thenStatement, elseStatement) {
      return typescript4Cast.updateIf(node, expression, thenStatement, elseStatement);
    },
    updateJSDocAugmentsTag(node, tagName, className, comment) {
      return tagName === node.tagName && className === node.class && comment === node.comment ? node : typescript.setTextRange(createJSDocAugmentsTag(tagName, className, comment), node);
    },
    updateJSDocAuthorTag(node, tagName, comment) {
      return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocAuthorTag(tagName, comment), node);
    },
    updateJSDocCallbackTag(node, tagName, typeExpression, fullName, comment) {
      return tagName === node.tagName && typeExpression === node.typeExpression && fullName === node.fullName && comment === node.comment ? node : typescript.setTextRange(createJSDocCallbackTag(tagName, typeExpression, fullName, comment), node);
    },
    updateJSDocClassTag(node, tagName, comment) {
      return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocClassTag(tagName, comment), node);
    },
    updateJSDocComment(node, comment, tags) {
      return comment === node.comment && tags === node.tags ? node : typescript.setTextRange(createJSDocComment(comment, tags), node);
    },
    updateJSDocDeprecatedTag(node, tagName, comment) {
      return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocDeprecatedTag(tagName, comment), node);
    },
    updateJSDocEnumTag(node, tagName, typeExpression, comment) {
      return tagName === node.tagName && typeExpression === node.typeExpression ? node : typescript.setTextRange(createJSDocEnumTag(tagName, typeExpression, comment), node);
    },
    updateJSDocFunctionType(node, parameters, type) {
      return parameters === node.parameters && type === node.type ? node : typescript.setTextRange(createJSDocFunctionType(parameters, type), node);
    },
    updateJSDocImplementsTag(node, tagName, className, comment) {
      return tagName === node.tagName && className === node.class && comment === node.comment ? node : typescript.setTextRange(createJSDocImplementsTag(tagName, className, comment), node);
    },
    updateJSDocLink(node, name, text) {
      return name === node.name && text === node.text ? node : typescript.setTextRange(createJSDocLink(name, text), node);
    },
    updateJSDocNameReference(node, name) {
      return name === node.name ? node : typescript.setTextRange(createJSDocNameReference(name), node);
    },
    updateJSDocNamepathType(node, type) {
      return type === node.type ? node : typescript.setTextRange(createJSDocNamepathType(type), node);
    },
    updateJSDocNonNullableType(node, type) {
      return type === node.type ? node : typescript.setTextRange(createJSDocNonNullableType(type), node);
    },
    updateJSDocNullableType(node, type) {
      return type === node.type ? node : typescript.setTextRange(createJSDocNullableType(type), node);
    },
    updateJSDocOptionalType(node, type) {
      return type === node.type ? node : typescript.setTextRange(createJSDocOptionalType(type), node);
    },
    updateJSDocOverrideTag(node, tagName, comment) {
      return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocOverrideTag(tagName, comment), node);
    },
    updateJSDocParameterTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
      return tagName === node.tagName && name === node.name && isBracketed === node.isBracketed && typeExpression === node.typeExpression && isNameFirst === node.isNameFirst && comment === node.comment ? node : typescript.setTextRange(createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node);
    },
    updateJSDocPrivateTag(node, tagName, comment) {
      return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocPrivateTag(tagName, comment), node);
    },
    updateJSDocPropertyTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
      return tagName === node.tagName && name === node.name && isBracketed === node.isBracketed && typeExpression === node.typeExpression && isNameFirst === node.isNameFirst && comment === node.comment ? node : typescript.setTextRange(createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node);
    },
    updateJSDocProtectedTag(node, tagName, comment) {
      return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocProtectedTag(tagName, comment), node);
    },
    updateJSDocPublicTag(node, tagName, comment) {
      return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocPublicTag(tagName, comment), node);
    },
    updateJSDocReadonlyTag(node, tagName, comment) {
      return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocReadonlyTag(tagName, comment), node);
    },
    updateJSDocReturnTag(node, tagName, typeExpression, comment) {
      return tagName === node.tagName && comment === node.comment && typeExpression === node.typeExpression ? node : typescript.setTextRange(createJSDocReturnTag(tagName, typeExpression, comment), node);
    },
    updateJSDocSeeTag(node, tagName, nameExpression, comment) {
      return tagName === node.tagName && nameExpression === node.name && comment === node.comment ? node : typescript.setTextRange(createJSDocSeeTag(tagName, nameExpression, comment), node);
    },
    updateJSDocSignature(node, typeParameters, parameters, type) {
      return typeParameters === node.typeParameters && parameters === node.parameters && type === node.type ? node : typescript.setTextRange(createJSDocSignature(typeParameters, parameters, type), node);
    },
    updateJSDocTemplateTag(node, tagName, constraint, typeParameters, comment) {
      return tagName === node.tagName && constraint === node.constraint && typeParameters === node.typeParameters && comment === node.comment ? node : typescript.setTextRange(createJSDocTemplateTag(tagName, constraint, typeParameters, comment), node);
    },
    updateJSDocText(node, text) {
      return text === node.text ? node : typescript.setTextRange(createJSDocText(text), node);
    },
    updateJSDocThisTag(node, tagName, typeExpression, comment) {
      return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment ? node : typescript.setTextRange(createJSDocThisTag(tagName, typeExpression, comment), node);
    },
    updateJSDocTypeExpression(node, type) {
      return type === node.type ? node : typescript.setTextRange(createJSDocTypeExpression(type), node);
    },
    updateJSDocTypeLiteral(node, jsDocPropertyTags, isArrayType) {
      return jsDocPropertyTags === node.jsDocPropertyTags && isArrayType === node.isArrayType ? node : typescript.setTextRange(createJSDocTypeLiteral(jsDocPropertyTags, isArrayType), node);
    },
    updateJSDocTypeTag(node, tagName, typeExpression, comment) {
      return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment ? node : typescript.setTextRange(createJSDocTypeTag(tagName, typeExpression, comment), node);
    },
    updateJSDocTypedefTag(node, tagName, typeExpression, fullName, comment) {
      return tagName === node.tagName && typeExpression === node.typeExpression && fullName === node.fullName && comment === node.comment ? node : typescript.setTextRange(createJSDocTypedefTag(tagName, typeExpression, fullName, comment), node);
    },
    updateJSDocUnknownTag(node, tagName, comment) {
      return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocUnknownTag(tagName, comment), node);
    },
    updateJSDocVariadicType(node, type) {
      return type === node.type ? node : typescript.setTextRange(createJSDocVariadicType(type), node);
    },
    updateJSDocMemberName(node, left, right) {
      return left === node.left && right === node.right ? node : typescript.setTextRange(createJSDocMemberName(left, right), node);
    },
    updateJSDocLinkCode(node, name, text) {
      return name === node.name && text === node.text ? node : typescript.setTextRange(createJSDocLinkCode(name, text), node);
    },
    updateJSDocLinkPlain(node, name, text) {
      return name === node.name && text === node.text ? node : typescript.setTextRange(createJSDocLinkPlain(name, text), node);
    },
    updateJSDocOverloadTag(node, tagName, typeExpression, comment) {
      return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment ? node : typescript.setTextRange(createJSDocOverloadTag(tagName, typeExpression, comment), node);
    },
    updateJSDocThrowsTag(node, tagName, typeExpression, comment) {
      return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment ? node : typescript.setTextRange(createJSDocThrowsTag(tagName ?? node.tagName, typeExpression, comment), node);
    },
    updateJSDocSatisfiesTag(node, tagName, typeExpression, comment) {
      return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment ? node : typescript.setTextRange(createJSDocSatisfiesTag(tagName, typeExpression, comment), node);
    },
    updateJSDocImportTag(node, tagName, importClause, moduleSpecifier, attributes, comment) {
      return tagName === node.tagName && importClause === node.importClause && comment === node.comment && moduleSpecifier === node.moduleSpecifier && attributes === node.attributes ? node : typescript.setTextRange(createJSDocImportTag(tagName, importClause, moduleSpecifier, attributes, comment), node);
    },
    updateLabeledStatement(node, label, statement) {
      return typescript4Cast.updateLabel(node, label, statement);
    },
    updateMethodDeclaration,
    updateNamedTupleMember(node, dotDotDotToken, name, questionToken, type) {
      return dotDotDotToken === node.dotDotDotToken && name === node.name && questionToken === node.questionToken && type === node.type ? node : typescript.setTextRange(createNamedTupleMember(dotDotDotToken, name, questionToken, type), node);
    },
    updateNewExpression(node, expression, typeArguments, argumentsArray) {
      return typescript4Cast.updateNew(node, expression, typeArguments, argumentsArray);
    },
    updateObjectLiteralExpression(node, properties) {
      return typescript4Cast.updateObjectLiteral(node, properties);
    },
    updateParameterDeclaration,
    updateParenthesizedExpression(node, expression) {
      return typescript4Cast.updateParen(node, expression);
    },
    updatePostfixUnaryExpression(node, operand) {
      return typescript4Cast.updatePostfix(node, operand);
    },
    updatePrefixUnaryExpression(node, operand) {
      return typescript4Cast.updatePrefix(node, operand);
    },
    updatePropertyAccessExpression(node, expression, name) {
      return typescript4Cast.updatePropertyAccess(node, expression, name);
    },
    updatePropertyDeclaration,
    updateReturnStatement(node, expression) {
      return typescript4Cast.updateReturn(node, expression);
    },
    updateSetAccessorDeclaration,
    updateSpreadElement(node, expression) {
      return typescript4Cast.updateSpread(node, expression);
    },
    updateSwitchStatement(node, expression, caseBlock) {
      return typescript4Cast.updateSwitch(node, expression, caseBlock);
    },
    updateTaggedTemplateExpression(node, tag, typeArguments, template) {
      return typescript4Cast.updateTaggedTemplate(node, tag, typeArguments, template);
    },
    updateTemplateLiteralType(node, head, templateSpans) {
      return head === node.head && templateSpans === node.templateSpans ? node : typescript.setTextRange(createTemplateLiteralType(head, templateSpans), node);
    },
    updateTemplateLiteralTypeSpan(node, type, literal) {
      return type === node.type && literal === node.literal ? node : typescript.setTextRange(createTemplateLiteralTypeSpan(type, literal), node);
    },
    updateClassStaticBlockDeclaration,
    updateAssertClause(node, elements, multiLine) {
      return node.elements !== elements || node.multiLine !== multiLine ? typescript.setTextRange(createAssertClause(elements, multiLine), node) : node;
    },
    updateAssertEntry(node, name, value) {
      return node.name !== name || node.value !== value ? typescript.setTextRange(createAssertEntry(name, value), node) : node;
    },
    updateImportTypeAssertionContainer(node, clause, multiLine) {
      return node.assertClause !== clause || node.multiLine !== multiLine ? typescript.setTextRange(createImportTypeAssertionContainer(clause, multiLine), node) : node;
    },
    updateImportAttributes(node, elements, multiLine) {
      return node.elements !== elements || node.multiLine !== multiLine ? typescript.setTextRange(createImportAttributes(elements, multiLine), node) : node;
    },
    updateImportAttribute(node, name, value) {
      return node.name !== name || node.value !== value ? typescript.setTextRange(createImportAttribute(name, value), node) : node;
    },
    updateJsxNamespacedName(node, namespace, name) {
      return node.namespace !== namespace || node.name !== name ? typescript.setTextRange(createJsxNamespacedName(namespace, name), node) : node;
    },
    updateThrowStatement(node, expression) {
      return typescript4Cast.updateThrow(node, expression);
    },
    updateTryStatement(node, tryBlock, catchClause, finallyBlock) {
      return typescript4Cast.updateTry(node, tryBlock, catchClause, finallyBlock);
    },
    updateTypeOfExpression(node, expression) {
      return typescript4Cast.updateTypeOf(node, expression);
    },
    updateVoidExpression(node, expression) {
      return typescript4Cast.updateVoid(node, expression);
    },
    updateWhileStatement(node, expression, statement) {
      return typescript4Cast.updateWhile(node, expression, statement);
    },
    updateWithStatement(node, expression, statement) {
      return typescript4Cast.updateWith(node, expression, statement);
    },
    updateYieldExpression(node, asteriskToken, expression) {
      return typescript4Cast.updateYield(node, asteriskToken, expression);
    },
    createImportClause(isTypeOnly, name, namedBindings) {
      return typescript4Cast.createImportClause(name, namedBindings, isTypeOnly);
    },
    createCallExpression(expression, typeArguments, argumentsArray) {
      return typescript4Cast.createCall(expression, typeArguments, argumentsArray);
    },
    updateCallExpression(node, expression, typeArguments, argumentsArray) {
      return typescript4Cast.updateCall(node, expression, typeArguments, argumentsArray);
    },
    createArrayLiteralExpression(elements, multiLine) {
      return typescript4Cast.createArrayLiteral(elements, multiLine);
    },
    updateArrayLiteralExpression(node, elements) {
      return typescript4Cast.updateArrayLiteral(node, elements);
    },
    updateSourceFile(node, statements, isDeclarationFile, referencedFiles, typeReferences, hasNoDefaultLib, libReferences) {
      return typescript4Cast.updateSourceFileNode(
        node,
        statements,
        isDeclarationFile,
        referencedFiles,
        typeReferences,
        hasNoDefaultLib,
        libReferences
      );
    },
    updateClassExpression,
    createPropertyAccessExpression(expression, name) {
      return typescript4Cast.createPropertyAccess(expression, name);
    },
    createGetAccessorDeclaration,
    updateGetAccessorDeclaration,
    createReturnStatement(expression) {
      return typescript4Cast.createReturn(expression);
    },
    createObjectLiteralExpression(properties, multiLine) {
      return typescript4Cast.createObjectLiteral(properties, multiLine);
    },
    createVariableDeclaration(name, exclamationToken, type, initializer) {
      if (typescript4Cast.createVariableDeclaration.length === 4) {
        return typescript4Cast.createVariableDeclaration(name, exclamationToken, type, initializer);
      }
      return typescript4Cast.createVariableDeclaration(name, type, initializer);
    },
    updateVariableDeclaration(node, name, exclamationToken, type, initializer) {
      if (typescript4Cast.updateVariableDeclaration.length === 4) {
        return typescript4Cast.updateVariableDeclaration(node, name, type, initializer);
      }
      return typescript4Cast.updateVariableDeclaration(node, name, exclamationToken, type, initializer);
    },
    createPropertyAccessChain(expression, questionDotToken, name) {
      if ("createPropertyAccessChain" in typescript) {
        return typescript4Cast.createPropertyAccessChain(expression, questionDotToken, name);
      }
      const node = typescript4Cast.createPropertyAccess(expression, name);
      node.questionDotToken = questionDotToken;
      return node;
    },
    updatePropertyAccessChain(node, expression, questionDotToken, name) {
      if ("updatePropertyAccessChain" in typescript) {
        return typescript4Cast.updatePropertyAccessChain(node, expression, questionDotToken, name);
      }
      const newNode = typescript4Cast.updatePropertyAccess(node, expression, name);
      newNode.questionDotToken = questionDotToken;
      return newNode;
    },
    createImportEqualsDeclaration,
    updateImportEqualsDeclaration,
    createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members) {
      return typescript.createMappedTypeNode(
        readonlyToken,
        typeParameter,
        questionToken,
        type
      );
    },
    updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type, members) {
      return typescript.updateMappedTypeNode(
        node,
        readonlyToken,
        typeParameter,
        questionToken,
        type
      );
    },
    createImportSpecifier(isTypeOnly, propertyName, name) {
      return typescript.createImportSpecifier(propertyName, name);
    },
    updateImportSpecifier(node, isTypeOnly, propertyName, name) {
      return typescript.updateImportSpecifier(
        node,
        propertyName,
        name
      );
    },
    createExportSpecifier(isTypeOnly, propertyName, name) {
      return typescript.createExportSpecifier(propertyName, name);
    },
    updateExportSpecifier(node, isTypeOnly, propertyName, name) {
      return typescript.updateExportSpecifier(
        node,
        propertyName,
        name
      );
    },
    createExportDeclaration,
    updateConstructorDeclaration,
    /**
     * Some TypeScript versions require that the value is a string argument
     */
    createNumericLiteral(value, numericLiteralFlags) {
      return typescript4Cast.createNumericLiteral(String(value), numericLiteralFlags);
    },
    replaceModifiers(n, modifiers) {
      let modifierArray;
      if (typeof modifiers === "number") {
        modifierArray = typescript4Cast.createModifiersFromModifierFlags(modifiers);
      } else {
        modifierArray = modifiers;
      }
      const clone = "cloneNode" in typescript4Cast ? typescript4Cast.cloneNode(n) : { ...n };
      clone.modifiers = typescript4Cast.createNodeArray(modifierArray);
      return clone;
    },
    replaceDecoratorsAndModifiers(n, modifiers) {
      const clone = "cloneNode" in typescript4Cast ? typescript4Cast.cloneNode(n) : { ...n };
      clone.modifiers = typescript4Cast.createNodeArray(modifiers);
      return clone;
    },
    replacePropertyName(n, name) {
      const clone = "cloneNode" in typescript4Cast ? typescript4Cast.cloneNode(n) : { ...n };
      clone.name = name;
      return clone;
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ensureNodeFactory
});
//# sourceMappingURL=index.cjs.map